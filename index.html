<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Geoportal Solicitudes Ciudadanas</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- PWA Configuration -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#922B21">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Geoportal">
  <link rel="apple-touch-icon" href="img/logo/logo.png">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- Leaflet MarkerCluster -->
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>

  <!-- SheetJS -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <!-- Proj4js para transformaci√≥n de coordenadas -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>

  <!-- Firebase CDN -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

<style>
  /* Base */
  body { margin:0; font-family:'Montserrat', sans-serif; }
  .navbar { background-color:#6d1f18; color:#fff; }
  .navbar-brand span { color:#fff; font-weight:600; }

  /* Layout principal */
  .main-container {
    display:flex;
    height:calc(100vh - 60px);
    margin-top:60px;
    position: relative;
    overflow: hidden; /* Ocultar cualquier contenido que salga del contenedor */
  }

  /* Sidebar */
  #sidebar {
    width:700px;
    background:#f5f5f5;
    padding:10px;
    overflow-y:auto;
    position: relative;
    transition: all 0.35s ease; /* Animar cambios */
    flex-shrink: 0; /* No reducir el sidebar */
  }

  /* Mapa */
  #map { 
    flex:1; 
    width: 100%;
    min-width: 0; /* Permitir que el mapa se comprima si es necesario */
  }
  canvas { margin-bottom:20px; }

  /* Pesta√±a de toggle (posicionada din√°micamente por JS) */
  #sidebarToggleTab {
    background: #922B21;
    color: #fff;
    padding: 8px 10px;
    font-size: 16px;
    cursor: pointer;
    z-index: 1001;
    border-radius: 0 4px 4px 0;
    user-select: none;
    border: none;
  }

  .sidebar-title {
    font-size: 12px;
    margin-top: 10px;
    margin-bottom: 8px;
  }

  .tabla-resumen table {
    font-size: 10px;
    border-collapse: collapse;
    width: 100%;
  }
  
  .tabla-resumen table th {
    text-align: center;
    vertical-align: middle;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    padding: 6px 4px;
    font-size: 9px;
  }
  
  .tabla-resumen table td {
    border: 1px solid #dee2e6;
    padding: 4px 6px;
  }

  .chart-container {
    height: 250px;
    position: relative;
    margin-bottom: 15px;
  }

  /* Contenedor espec√≠fico para gr√°fica de colonias (m√°s alto para mostrar todos los nombres) */
  #chartColonias {
    max-height: 450px !important;
  }

  /* Encabezados ordenables en tabla din√°mica */
  .sortable-header {
    cursor: pointer;
    user-select: none;
    position: relative;
    padding-right: 20px !important;
  }
  
  .sortable-header:hover {
    background-color: rgba(255, 255, 255, 0.1) !important;
  }
  
  .sortable-header::after {
    content: '‚Üï';
    position: absolute;
    right: 5px;
    opacity: 0.3;
    font-size: 12px;
  }
  
  .sortable-header.sort-asc::after {
    content: '‚Üë';
    opacity: 1;
  }
  
  .sortable-header.sort-desc::after {
    content: '‚Üì';
    opacity: 1;
  }

  /* Loading overlay */
  #loadingOverlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.45);
    z-index: 3000;
    align-items: center;
    justify-content: center;
    color: #fff;
  }
  #loadingOverlay[style*="display: flex"] {
    display: flex !important;
  }
  #loadingOverlay .box {
    background: rgba(0,0,0,0.7);
    padding: 12px 18px;
    border-radius: 6px;
    font-size: 16px;
    font-weight: 600;
  }

  /* Estilos para datalist en m√≥viles */
  datalist, datalist option {
    background: white;
    color: black;
    padding: 8px;
  }
  datalist option {
    padding: 8px;
    background: white;
    color: black;
  }

  /* Autocompletado (fallback m√≥vil) */
  .input-group { position: relative; }
  .autocomplete-list {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    max-height: 240px;
    overflow-y: auto;
    background: #fff;
    border: 1px solid #ccc;
    border-top: none;
    z-index: 3000;
    box-shadow: 0 4px 10px rgba(0,0,0,0.08);
  }
  .autocomplete-item {
    padding: 8px 10px;
    cursor: pointer;
    font-size: 14px;
    line-height: 1.2;
  }
  .autocomplete-item:hover { background: #f3f3f3; }

  /* Modal tabla ciudadanos */
  #modalCiudadanos {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    z-index: 4000;
    overflow: auto;
  }
  #modalCiudadanos .modal-content {
    background: white;
    margin: 40px auto;
    padding: 20px;
    max-width: 900px;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  }
  #modalCiudadanos .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    border-bottom: 2px solid #922B21;
    padding-bottom: 10px;
  }
  #modalCiudadanos .close-btn {
    background: #922B21;
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
  }
  #modalCiudadanos .close-btn:hover { background: #6d1f18; }
  
  /* Pesta√±as de navegaci√≥n */
  .tabs-container {
    display: flex;
    gap: 8px;
    margin-bottom: 15px;
    border-bottom: 2px solid #ddd;
  }
  .tab-btn {
    background: #f5f5f5;
    border: none;
    padding: 10px 20px;
    cursor: pointer;
    font-family: 'Montserrat', sans-serif;
    font-size: 13px;
    font-weight: 600;
    color: #555;
    border-radius: 4px 4px 0 0;
    transition: all 0.2s;
  }
  .tab-btn:hover { background: #e0e0e0; }
  .tab-btn.active {
    background: #922B21;
    color: white;
  }
  .tab-content {
    display: none;
  }
  .tab-content.active {
    display: block;
  }
  
  .tabla-ciudadanos {
    width: 100%;
    font-size: 11px;
    border-collapse: collapse;
  }
  .tabla-ciudadanos th {
    background-color: #922B21;
    color: white;
    text-align: center;
    padding: 8px 6px;
    border: 1px solid #ddd;
  }
  .tabla-ciudadanos td {
    padding: 6px 8px;
    border: 1px solid #ddd;
    text-align: left;
  }
  .tabla-ciudadanos tr:hover { background-color: #f5f5f5; }
  
  .toggle-row {
    user-select: none;
  }
  .toggle-row:hover { background-color: #f5f5f5; }
  
  /* ===== ESTILOS CHATBOT IA ===== */
  #chatbotContainer {
    position: fixed;
    top: 60px;
    right: -450px;
    width: 450px;
    height: calc(100vh - 60px);
    background: white;
    border-left: 3px solid #922B21;
    box-shadow: -4px 0 20px rgba(0,0,0,0.15);
    z-index: 5000;
    display: flex;
    flex-direction: column;
    transition: right 0.4s ease;
  }
  #chatbotContainer.open {
    right: 0;
  }
  
  #chatbotToggleBtn {
    position: fixed;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    background: linear-gradient(135deg, #922B21 0%, #6d1f18 100%);
    color: white;
    border: none;
    padding: 20px 12px;
    cursor: pointer;
    z-index: 5001;
    border-radius: 8px 0 0 8px;
    font-size: 16px;
    font-weight: 600;
    writing-mode: vertical-rl;
    text-orientation: mixed;
    box-shadow: -2px 0 10px rgba(0,0,0,0.2);
    transition: all 0.3s ease;
  }
  #chatbotToggleBtn:hover {
    background: linear-gradient(135deg, #6d1f18 0%, #4a1410 100%);
    padding-left: 15px;
  }
  
  #chatbotHeader {
    background: linear-gradient(135deg, #922B21 0%, #6d1f18 100%);
    color: white;
    padding: 15px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
    border-bottom: 2px solid #6d1f18;
  }
  #chatbotHeader h4 {
    margin: 0;
    font-size: 16px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  #chatbotHeader .controls {
    display: flex;
    gap: 8px;
  }
  #chatbotHeader button {
    background: rgba(255,255,255,0.2);
    border: none;
    color: white;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 600;
    transition: background 0.2s;
  }
  #chatbotHeader button:hover {
    background: rgba(255,255,255,0.35);
  }
  #chatbotMessages {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    background: #f9f9f9;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .chat-message {
    padding: 12px 16px;
    border-radius: 12px;
    font-size: 14px;
    line-height: 1.6;
    animation: fadeIn 0.3s ease;
    max-width: 70%;
  }
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .chat-message.user {
    background: #922B21;
    color: white;
    align-self: flex-end;
    border-radius: 12px 12px 2px 12px;
  }
  .chat-message.assistant {
    background: white;
    color: #333;
    align-self: flex-start;
    border: 2px solid #e0e0e0;
    border-radius: 12px 12px 12px 2px;
  }
  .chat-message.system {
    background: white;
    color: #333;
    text-align: left;
    font-size: 14px;
    padding: 12px 16px;
    align-self: flex-start;
    border: 2px solid #e0e0e0;
    border-radius: 12px 12px 12px 2px;
    max-width: 85%;
    white-space: pre-wrap;
  }
  .chatbot-chart-container {
    width: 100%;
    max-height: 300px;
    margin-top: 10px;
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  .chatbot-chart-container canvas {
    max-height: 280px;
  }
  .chatbot-table-container {
    width: 100%;
    max-height: 400px;
    overflow-y: auto;
    margin-top: 10px;
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  .chatbot-table-container table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
  }
  .chatbot-table-container th {
    background: #922B21;
    color: white;
    padding: 10px 8px;
    text-align: left;
    position: sticky;
    top: 0;
    z-index: 10;
  }
  .chatbot-table-container td {
    padding: 8px;
    border-bottom: 1px solid #e0e0e0;
  }
  .chatbot-table-container tr:hover {
    background: #f5f5f5;
  }
  .chatbot-table-container .total-row {
    font-weight: bold;
    background: #f9f9f9;
    border-top: 2px solid #922B21;
  }
  #chatbotInput {
    display: flex;
    padding: 15px 20px;
    background: white;
    border-top: 2px solid #e0e0e0;
    flex-shrink: 0;
    gap: 12px;
    align-items: center;
  }
  #chatbotInput input {
    flex: 1;
    border: 2px solid #ddd;
    border-radius: 25px;
    padding: 12px 20px;
    font-size: 14px;
    outline: none;
    transition: all 0.2s;
  }
  #chatbotInput input:focus {
    border-color: #922B21;
    box-shadow: 0 0 0 3px rgba(146, 43, 33, 0.1);
  }
  #chatbotInput button {
    background: #922B21;
    color: white;
    border: none;
    border-radius: 25px;
    padding: 12px 30px;
    cursor: pointer;
    font-weight: 600;
    font-size: 14px;
    transition: all 0.2s;
    flex-shrink: 0;
  }
  #chatbotInput button:hover {
    background: #6d1f18;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(146, 43, 33, 0.3);
  }
  #chatbotInput button:disabled {
    background: #ccc;
    cursor: not-allowed;
    transform: none;
  }
  .typing-indicator {
    display: flex;
    gap: 4px;
    padding: 10px;
  }
  .typing-indicator span {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #fff8e1;
    border-bottom: 2px solid #ffd54f;
    font-size: 13px;
    flex-shrink: 0;
  }
  #apiKeyConfig input {
    width: 100%;
    padding: 10px 12px;
    border: 2px solid #ddd;
    border-radius: 6px;
    margin-top: 10px;
    font-size: 13px;
  }
  #apiKeyConfig button {
    background: #922B21;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    margin-top: 10px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 600;
  }
  #apiKeyConfig button:hover {
    background: #6d1f18;
    font-size: 12px;
  }
  #apiKeyConfig button {
    background: #922B21;
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    margin-top: 8px;
    cursor: pointer;
    font-size: 12px;
  }
  .toggle-icon {
    display: inline-block;
    width: 16px;
    font-weight: bold;
    text-align: center;
  }
  .detail-row {
    display: none;
    background-color: #fafafa;
  }
  .detail-row.show { display: table-row; }
  .detail-content {
    padding: 10px 20px;
    font-size: 10px;
  }
  .detail-table {
    width: 100%;
    margin-top: 5px;
  }
  .detail-table th {
    background-color: #e9ecef;
    padding: 4px 6px;
    text-align: left;
    border: 1px solid #ccc;
  }
  .detail-table td {
    padding: 3px 6px;
    border: 1px solid #ddd;
  }
  
  /* Selecci√≥n de celdas estilo Excel */
  .tabla-ciudadanos td.selected,
  .detail-table td.selected,
  td.selected {
    background-color: #0d6efd !important;
    color: white !important;
    outline: 2px solid #084298;
    position: relative;
    z-index: 1;
  }
  
  .stats-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: #922B21;
    color: white;
    padding: 10px 20px;
    font-family: 'Montserrat', sans-serif;
    font-size: 14px;
    font-weight: 600;
    z-index: 99999;
    display: none;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
    box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
  }
  
  .stats-bar span {
    margin-right: 20px;
  }

  /* ========== ESTILOS PARA LOGIN ========== */
  #loginContainer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #922B21 0%, #6d1f18 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
  }

  .login-box {
    background: white;
    padding: 40px;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    width: 90%;
    max-width: 400px;
    text-align: center;
  }

  .login-box img {
    width: 80px;
    margin-bottom: 20px;
  }

  .login-box h2 {
    color: #922B21;
    margin-bottom: 10px;
    font-size: 24px;
    font-weight: 700;
  }

  .login-box p {
    color: #666;
    margin-bottom: 30px;
    font-size: 14px;
  }

  .login-box input {
    width: 100%;
    padding: 12px;
    margin: 10px 0;
    border: 2px solid #ddd;
    border-radius: 6px;
    box-sizing: border-box;
    font-size: 14px;
    transition: border-color 0.3s;
  }

  .login-box input:focus {
    outline: none;
    border-color: #922B21;
  }

  .login-box button {
    background: #922B21;
    color: white;
    padding: 12px 20px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    width: 100%;
    margin-top: 10px;
    font-size: 16px;
    font-weight: 600;
    transition: background 0.3s;
  }

  .login-box button:hover {
    background: #6d1f18;
  }

  #errorLogin {
    color: #dc3545;
    margin-top: 15px;
    font-size: 13px;
    min-height: 20px;
  }

  #geoportalContent {
    display: none;
  }

  .logout-btn {
    position: absolute;
    top: 70px;
    right: 20px;
    background: #dc3545;
    color: white;
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    z-index: 1000;
  }

  .logout-btn:hover {
    background: #c82333;
  }

  .user-info {
    position: absolute;
    top: 70px;
    right: 140px;
    background: white;
    padding: 6px 12px;
    border-radius: 4px;
    font-size: 12px;
    color: #922B21;
    font-weight: 600;
    z-index: 1000;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }

  /* Spinner de carga */
  .spinner-container {
    display: none;
    margin-top: 15px;
    text-align: center;
  }

  .spinner {
    border: 3px solid #f3f3f3;
    border-top: 3px solid #922B21;
    border-radius: 50%;
    width: 35px;
    height: 35px;
    animation: spin 1s linear infinite;
    margin: 0 auto;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .spinner-text {
    margin-top: 10px;
    font-size: 13px;
    color: #922B21;
    font-weight: 500;
  }
</style>
</head>
<body>

  <!-- ========== PANTALLA DE LOGIN ========== -->
  <div id="loginContainer">
    <div class="login-box">
      <img src="img/logo/logo.png" alt="Logo">
      <h2>Acceso al Geoportal</h2>
      <p>Solicitudes Ciudadanas Dalia - Alcald√≠a √Ålvaro Obreg√≥n</p>
      <form id="loginForm">
        <input type="email" id="emailLogin" placeholder="Correo electr√≥nico" required>
        <input type="password" id="passwordLogin" placeholder="Contrase√±a" required>
        <button type="submit" id="btnLogin">Iniciar Sesi√≥n</button>
        <div class="spinner-container" id="loginSpinner" aria-live="polite" aria-hidden="true">
          <div class="spinner" role="status" aria-label="Validando acceso"></div>
          <div class="spinner-text">Validando acceso...</div>
        </div>
        <div id="errorLogin"></div>
      </form>
    </div>
  </div>

  <!-- ========== CONTENIDO DEL GEOPORTAL (oculto hasta login) ========== -->
  <div id="geoportalContent">

  <!-- Bot√≥n de cerrar sesi√≥n -->
  <button class="logout-btn" id="btnLogout">Cerrar Sesi√≥n</button>
  <div class="user-info" id="userInfo"></div>

  <!-- Encabezado -->
  <nav class="navbar navbar-expand-lg fixed-top">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">
        <img src="img/logo/logo.png" alt="logo" style="height:40px;">
        <span>Solicitudes Ciudadanas - Alcald√≠a √Ålvaro Obreg√≥n</span>
      </a>
    </div>
  </nav>

  <!-- Aviso para m√≥viles: girar el celular (DESHABILITADO) -->
  <!-- <div id="rotateMessage" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.7);z-index:2000;align-items:center;justify-content:center;color:#fff;">
    <div style="text-align:center;padding:20px;max-width:320px;margin:auto;">
      <div style="font-size:28px;margin-bottom:10px;">‚Ü™Ô∏è</div>
      <div style="font-size:18px;font-weight:600;">Gire su dispositivo</div>
      <div style="margin-top:8px;font-size:14px;">Para una mejor visualizaci√≥n, use el modo horizontal.</div>
    </div>
  </div> -->

  <!-- Overlay de carga -->
  <div id="loadingOverlay"><div class="box">Cargando datos</div></div>

  <!-- Modal Tabla Ciudadanos -->
  <div id="modalCiudadanos">
    <div class="modal-content">
      <div class="modal-header">
        <h3 style="margin:0; color:#922B21; font-family:'Montserrat', sans-serif;">An√°lisis de Solicitudes</h3>
        <button class="close-btn" id="btnCerrarModal">Cerrar</button>
      </div>
      
      <!-- Pesta√±as -->
      <div class="tabs-container">
        <button class="tab-btn active" data-tab="tab-general">Tabla General</button>
        <button class="tab-btn" data-tab="tab-ciudadanos">Por Ciudadano</button>
        <button class="tab-btn" data-tab="tab-tipos">Por Tipo de Solicitud</button>
        <button class="tab-btn" data-tab="tab-dinamica">Tabla Din√°mica</button>
      </div>
      
      <!-- Contenido Pesta√±a 1: Tabla General -->
      <div id="tab-general" class="tab-content active">
        <div id="contenidoTablaGeneral" style="max-height: 65vh; overflow-y: auto;"></div>
      </div>
      
      <!-- Contenido Pesta√±a 2: Por Ciudadano -->
      <div id="tab-ciudadanos" class="tab-content">
        <div id="contenidoTablaCiudadanos" style="max-height: 65vh; overflow-y: auto;"></div>
      </div>
      
      <!-- Contenido Pesta√±a 3: Por Tipo -->
      <div id="tab-tipos" class="tab-content">
        <div id="contenidoTablaTipos" style="max-height: 65vh; overflow-y: auto;"></div>
      </div>
      
      <!-- Contenido Pesta√±a 4: Tabla Din√°mica -->
      <div id="tab-dinamica" class="tab-content">
        <div style="padding: 15px; background: #f8f9fa; border-radius: 8px; margin-bottom: 15px;">
          <h5 style="color: #922B21; margin-bottom: 15px;">Configurar Tabla Din√°mica</h5>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
            <div>
              <label style="font-weight: 600; font-size: 13px; display: block; margin-bottom: 5px;">Fila Principal (Agrupar por):</label>
              <select id="dinamicaFilas" class="form-select form-select-sm">
                <option value="Tipo de reporte">Tipo de Reporte</option>
                <option value="Estado Reporte">Estado Reporte</option>
                <option value="name">Colonia</option>
                <option value="mes">Mes</option>
                <option value="Nombre Ciudadano">Ciudadano</option>
                <option value="Punto de referencia">Punto de Referencia</option>
              </select>
            </div>
            
            <div>
              <label style="font-weight: 600; font-size: 13px; display: block; margin-bottom: 5px;">Fila Secundaria (Subgrupo):</label>
              <select id="dinamicaFilas2" class="form-select form-select-sm">
                <option value="ninguna">Ninguna</option>
                <option value="Estado Reporte">Estado Reporte</option>
                <option value="Tipo de reporte">Tipo de Reporte</option>
                <option value="mes">Mes</option>
                <option value="name">Colonia</option>
                <option value="Nombre Ciudadano">Ciudadano</option>
              </select>
            </div>
          </div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
            <div>
              <label style="font-weight: 600; font-size: 13px; display: block; margin-bottom: 5px;">Columnas:</label>
              <select id="dinamicaColumnas" class="form-select form-select-sm">
                <option value="ninguna">Ninguna</option>
                <option value="mes">Mes</option>
                <option value="Estado Reporte">Estado Reporte</option>
                <option value="Tipo de reporte">Tipo de Reporte</option>
                <option value="name">Colonia</option>
              </select>
            </div>
            
            <div>
              <label style="font-weight: 600; font-size: 13px; display: block; margin-bottom: 5px;">Valores:</label>
              <select id="dinamicaValores" class="form-select form-select-sm">
                <option value="contar">Contar Solicitudes</option>
                <option value="porcentaje">Porcentaje</option>
              </select>
            </div>
          </div>
          
          <div style="display: flex; gap: 10px; align-items: center;">
            <button id="btnGenerarDinamica" class="btn btn-sm" style="background-color:#922B21; color:white; font-weight:600;">Generar Tabla</button>
            <label style="font-size: 12px;">
              <input type="checkbox" id="dinamicaMostrarTotales" checked> Mostrar totales
            </label>
            <label style="font-size: 12px;">
              <input type="checkbox" id="dinamicaOrdenar" checked> Ordenar por total
            </label>
          </div>
        </div>
        
        <div id="contenidoTablaDinamica" style="max-height: 55vh; overflow: auto;"></div>
      </div>
    </div>
  </div>

  <!-- Contenedor principal -->
  <div class="main-container">

    <!-- Pesta√±a flotante de toggle (fuera del sidebar para evitar conflictos de posicionamiento) -->
    <div id="sidebarToggleTab">‚ò∞</div>

    <!-- Sidebar -->
    <div id="sidebar">
      <h4 class="sidebar-title">Buscar por folio, colonia o secci√≥n</h4>
      <div class="input-group mb-3">
        <input type="text" id="buscadorGeneral" class="form-control" placeholder="Ingrese folio, colonia o secci√≥n" autocomplete="off">
        <datalist id="sugerenciasColonias" style="display:none;"></datalist>
        <button class="btn btn-primary btn-sm" id="btnBuscarGeneral">Buscar</button>
        <button class="btn btn-secondary btn-sm" id="btnResetBuscar">Limpiar</button>
      </div>

      <button class="btn btn-sm mb-3" id="btnVerCiudadanos" style="background-color:#922B21; color:white; font-weight:600;">Ver An√°lisis</button>

      <h4 class="sidebar-title">Filtrar por tipo</h4>
      <select id="filtroTipo" class="form-select mb-3">
        <option value="Todos">Todos</option>
      </select>

      <h4 class="sidebar-title">Filtrar por estado</h4>
      <select id="filtroEstado" class="form-select mb-3">
        <option value="Todos">Todos</option>
      </select>

      <h4 class="sidebar-title">Filtrar por mes</h4>
      <select id="filtroMes" class="form-select mb-3">
        <option value="Todos">Todos</option>
      </select>

      <button class="btn btn-sm mb-3" id="btnAplicarFiltros" style="background-color:#922B21; color:white; font-weight:600;">Aplicar filtros</button>

      <div id="contadorSolicitudes" style="display:none; text-align:center; font-family:'Montserrat', sans-serif; font-size:14px; font-weight:600; color:#922B21; margin-bottom:15px; line-height:1.6;">
        <div>Total de solicitudes: <span id="totalSolicitudes">0</span></div>
        <div style="font-size:12px; color:#666; margin-top:6px;">
          Vialidades primarias: <span id="vialidadesPrimarias">0</span> &nbsp;|&nbsp;
          Vialidades locales: <span id="vialidadesLocales">0</span>
        </div>
      </div>

      <h4 class="sidebar-title">Estad√≠sticas</h4>
      <div class="chart-container">
        <canvas id="chartMesesEstados"></canvas>
      </div>
      <div class="chart-container">
        <canvas id="chartTipos"></canvas>
      </div>
      <div class="chart-container">
        <canvas id="chartColonias"></canvas>
      </div>
      <div class="chart-container">
        <canvas id="chartEstados"></canvas>
      </div>

      <h4 class="sidebar-title">Top 10 Solicitudes Pendientes con mayor demanda</h4>
      <div id="tablaTop10" class="tabla-resumen"></div>
      
      <h4 class="sidebar-title">Tabla resumen</h4>
      <div id="tablaResumen" class="tabla-resumen"></div>
      
      <h4 class="sidebar-title" style="margin-top: 20px;">Tabla secciones</h4>
      <div id="tablaSecciones" class="tabla-resumen"></div>
    </div>

    <!-- Mapa -->
    <div id="map"></div>
  </div>

  <!-- Barra de estad√≠sticas (estilo Excel) -->
  <div id="statsBar" class="stats-bar">
    <span>Recuento: <span id="statCount">0</span></span>
    <span>Suma: <span id="statSum">0</span></span>
    <span>Promedio: <span id="statAvg">0</span></span>
  </div>

<script>
  // ========== VARIABLES GLOBALES ==========
  // Detectar si es m√≥vil (RECALCULAR din√°micamente)
  let isMobile = window.innerWidth <= 768;
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  
  // Declaraciones e inicializaci√≥n de variables globales usadas en el script
  var map;
  var coloniasLayer = null;
  var seccionesLayer = null;
  var vialidadesLayer = null;
  var limiteAlcaldiaLayer = null;
  var solicitudesGeoJSON = null;
  var solicitudes = [];
  var solicitudPorId = {};
  var allIds = [];
  var indiceTipo = {};
  var indiceEstado = {};
  var indiceMes = {};
  var estadisticasPorColonia = {};
  
  // ‚úÖ NUEVA OPTIMIZACI√ìN: Datos separados por mes
  var solicitudesPorMes = {
    'junio': { geojson: null, solicitudes: [], ids: [] },
    'julio': { geojson: null, solicitudes: [], ids: [] },
    'agosto': { geojson: null, solicitudes: [], ids: [] },
    'septiembre': { geojson: null, solicitudes: [], ids: [] },
    'octubre': { geojson: null, solicitudes: [], ids: [] },
    'noviembre': { geojson: null, solicitudes: [], ids: [] },
    'diciembre': { geojson: null, solicitudes: [], ids: [] }
  };
  
  // ‚úÖ √çNDICES POR MES+TIPO Y MES+ESTADO para filtrado ULTRA R√ÅPIDO
  var indiceMesTipo = {}; // { 'junio:Bache': [id1, id2, ...], ... }
  var indiceMesEstado = {}; // { 'junio:Pendiente': [id1, id2, ...], ... }
  var statsData = null;
  var statsLoaded = false;
  
  var mesesCargados = 0;
  var totalMeses = 7;
  var estadisticasPorSeccion = {};
  var puntosLayer = null;
  var legendControl = null;
  var puntosToggleControl = null;
  var coloniasToggleControl = null;
  var seccionesToggleControl = null;
  var chartTipos = null, chartColonias = null, chartEstados = null, chartMesesEstados = null;
  var showPuntos = false;
  var zoomendHandlerAdded = false;
  var coloniaSeleccionada = null;
  var seccionSeleccionada = null;
  var selectedOutline = null;
  var normToColoniaName = {};
  var normToSeccionName = {};
  var lastTipoForTable = null;
  var showColonias = true;
  var showSecciones = false;
  var isRendering = false;
  var pendingRenderArgs = null;
  var renderizarDebounced = null;
  var geoportalDataStarted = false;
  var modoIOSLigero = isIOS;
  
  // Lista de colonias para autocompletado (fallback m√≥vil)
  var coloniasList = [];
  var seccionesList = [];
  var autocompleteContainer = null;
  
  // Cach√© para tablas ya generadas
  // ‚úÖ CACH√â para tabla Top 10 completamente est√°tica
  var tablaCacheTop10 = null;  // Almacenar HTML de la tabla generada UNA sola vez
  
  var tablasGeneradas = {
    ciudadanos: false,
    tipos: false
  };
  
  // Variables para tabla din√°mica ordenable
  var tablaDinamicaDatos = null;
  var tablaDinamicaConfig = null;
  var tablaDinamicaSortCol = null;
  var tablaDinamicaSortDir = 'desc'; // 'asc' o 'desc'
  
  // Variables para selecci√≥n de celdas
  var isDraggingSelection = false;
  
  // ‚úÖ NUEVA OPTIMIZACI√ìN: √çndice espacial para matching r√°pido de coordenadas
  var coordIndexMap = new Map(); // Clave: "lon,lat" -> array de IDs
  
  // üî¥ CONTROL DE LAZY LOADING: Marcadores NO se cargan al inicio
  var puntosYaCargados = false; // Se activan solo cuando usuario hace click en ojo

  function inicializarMapaSiNecesario() {
    if (map) return;
    try {
      map = L.map('map').setView([19.35, -99.2], 13);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);
    } catch (e) {
      console.error('Error inicializando mapa:', e);
    }
  }

  // FUNCI√ìN ANTIGUA DESHABILITADA - Ver generarTablaResumen nueva en l√≠nea ~2509
  /*
  function generarTablaResumen(datos){
    // Mantener la funci√≥n original por compatibilidad si hace falta
    let resumen = {};
    datos.forEach(s => {
      if(!s["Fecha reporte"] || !s["Estado Reporte"]) return;
      let fecha = new Date(s["Fecha reporte"]);
      if(isNaN(fecha)) return;

      let mesClave = fecha.getFullYear()+"-"+(fecha.getMonth()+1).toString().padStart(2,"0");
      if(!resumen[mesClave]) {
        resumen[mesClave] = { Atendido:0, Pendiente:0, "En atenci√≥n":0, "No compete":0 };
      }

      let estado = s["Estado Reporte"].trim();
      if(estado==="Pendiente") resumen[mesClave].Pendiente++;
      else if(estado==="En atenci√≥n") resumen[mesClave]["En atenci√≥n"]++;
      else if(estado==="Atendido") resumen[mesClave].Atendido++;
      else if(estado==="No compete") resumen[mesClave]["No compete"]++;
    });

    let mesesOrdenados = Object.keys(resumen).sort();
    let tabla = `<table class="table table-striped"><thead><tr>
      <th>Mes</th><th>Atendido</th><th>Pendiente</th><th>En atenci√≥n</th><th>No compete</th>
    </tr></thead><tbody>`;
    let totales = { Atendido: 0, Pendiente: 0, "En atenci√≥n": 0, "No compete": 0 };
    mesesOrdenados.forEach(m => {
      const r = resumen[m];
      const [anio, mesNum] = m.split("-");
      let nombreMes = new Date(anio, parseInt(mesNum) - 1).toLocaleString('es-ES', { month: 'long' });
      nombreMes = nombreMes.charAt(0).toUpperCase() + nombreMes.slice(1);
      tabla += `<tr>
        <td>${nombreMes} ${anio}</td>
        <td>${r.Atendido}</td>
        <td>${r.Pendiente}</td>
        <td>${r["En atenci√≥n"]}</td>
        <td>${r["No compete"]}</td>
      </tr>`;
      Object.keys(totales).forEach(k => { totales[k] += r[k]; });
    });
    tabla += `<tr style="font-weight:bold;">
      <td>Total</td>
      <td>${totales.Atendido}</td>
      <td>${totales.Pendiente}</td>
      <td>${totales["En atenci√≥n"]}</td>
      <td>${totales["No compete"]}</td>
    </tr></tbody></table>`;
    document.getElementById("tablaResumen").innerHTML = tabla;
  }
  */

  // Generar tabla est√°tica: Top 10 colonias y √öltimas 10 solicitudes seg√∫n filtro Tipo
  function generarTablaEstatica(tipo) {
    // Filtrar por tipo (o todos)
    const filtradasPorTipo = solicitudes.filter(s => {
      if (!s) return false;
      if (tipo === 'Todos' || !tipo) return true;
      return s["Tipo de reporte"] === tipo;
    });

    // Top 10 colonias
    const conteoCol = {};
    filtradasPorTipo.forEach(s => {
      const col = s["Colonia"] || 'Sin colonia';
      conteoCol[col] = (conteoCol[col] || 0) + 1;
    });
    const topColonias = Object.entries(conteoCol)
      .map(([col, cnt]) => ({col, cnt}))
      .sort((a,b) => b.cnt - a.cnt)
      .slice(0,10);

    // √öltimas 10 solicitudes (por fecha)
    const ultimasSolicitudes = filtradasPorTipo
      .filter(s => s["Fecha reporte"])
      .map(s => ({
        folio: s["N√∫mero folio"],
        fecha: new Date(s["Fecha reporte"]),
        colonia: s["Colonia"] || 'Sin colonia',
        ciudadano: s["Nombre Ciudadano"] || 'N/A',
        telefono: s["Tel√©fono"] || 'N/A',
        tipo: s["Tipo de reporte"] || 'N/A',
        estado: s["Estado Reporte"] || 'N/A',
        referencia: s["Punto de referencia"] || 'N/A'
      }))
      .filter(x => !isNaN(x.fecha))
      .sort((a,b) => b.fecha - a.fecha)
      .slice(0,10);

    // Construir HTML
    let html = '<div style="display:flex;flex-direction:column;gap:12px">';

    // Top Colonias
    html += '<div><b>Top 10 Colonias (por n√∫mero de solicitudes)</b>';
    html += '<table class="table table-sm"><thead><tr><th>Colonia</th><th>Total</th></tr></thead><tbody>';
    topColonias.forEach(c => {
      html += `<tr><td>${c.col}</td><td>${c.cnt}</td></tr>`;
    });
    if (topColonias.length === 0) html += '<tr><td colspan="2">No hay datos</td></tr>';
    html += '</tbody></table></div>';

    // √öltimas solicitudes
    html += '<div><b>√öltimas 10 Solicitudes</b>';
    html += '<table class="table table-sm"><thead><tr><th>Folio</th><th>Fecha</th><th>Colonia</th><th>Ciudadano</th><th>Tel√©fono</th><th>Tipo</th><th>Estado</th></tr></thead><tbody>';
    ultimasSolicitudes.forEach(s => {
      html += `<tr><td>${s.folio}</td><td>${s.fecha.toLocaleString()}</td><td>${s.colonia}</td><td>${s.ciudadano}</td><td>${s.telefono}</td><td>${s.tipo}</td><td>${s.estado}</td></tr>`;
    });
    if (ultimasSolicitudes.length === 0) html += '<tr><td colspan="7">No hay solicitudes</td></tr>';
    html += '</tbody></table></div>';

    html += '</div>';
    document.getElementById('tablaResumen').innerHTML = html;
  }

  function classColor(i){
    const colors = ['#DBD8D7','#FAEAE3','#FD9D8C','#F72F35','#99250F','#4A0E03'];
    return colors[Math.min(Math.max(i,0), colors.length-1)];
  }

  function getJenksBreaks(data, numClasses) {
    data = data.filter(v => !isNaN(v)).sort((a, b) => a - b);
    if (data.length === 0) return [];

    let matrices = [], variance = [];
    for (let i = 0; i < data.length + 1; i++) {
      let tmp1 = [], tmp2 = [];
      for (let j = 0; j < numClasses + 1; j++) { tmp1.push(0); tmp2.push(0); }
      matrices.push(tmp1); variance.push(tmp2);
    }

    for (let i = 1; i < numClasses + 1; i++) {
      matrices[0][i] = 1; variance[0][i] = 0;
      for (let j = 1; j < data.length + 1; j++) { variance[j][i] = Infinity; }
    }

    for (let l = 2; l < data.length + 1; l++) {
      let sum = 0, sumSquares = 0, w = 0;
      for (let m = 1; m < l + 1; m++) {
        let i3 = l - m + 1, val = data[i3 - 1];
        w++; sum += val; sumSquares += val * val;
        let varianceVal = sumSquares - (sum * sum) / w;
        let i4 = i3 - 1;
        if (i4 !== 0) {
          for (let j = 2; j < numClasses + 1; j++) {
            if (variance[l][j] >= (varianceVal + variance[i4][j - 1])) {
              variance[l][j] = varianceVal + variance[i4][j - 1];
              matrices[l][j] = i3;
            }
          }
        }
      }
      variance[l][1] = sumSquares - (sum * sum) / w;
      matrices[l][1] = 1;
    }

    let k = data.length, kclass = [];
    for (let j = numClasses; j > 0; j--) {
      let id = matrices[k][j] - 1;
      kclass.push(data[id]);
      k = matrices[k][j] - 1;
    }
    kclass.push(data[data.length - 1]);
    return kclass.reverse();
  }

  // Normalizar cadenas: trim, may√∫sculas, eliminar tildes/diacr√≠ticos, quitar signos
  function normalizeKey(s) {
    if (s === undefined || s === null) return null;
    try {
      return String(s)
        .trim()
        .toUpperCase()
        .normalize('NFD')
        .replace(/[\u0000-\u001F\u007F]/g, '')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^A-Z0-9\s]/g, '')
        .replace(/\s+/g, ' ');
    } catch (e) {
      return String(s).trim().toUpperCase();
    }
  }

  // Normalizar claves de secci√≥n: prioriza d√≠gitos, fallback a normalizeKey
  function normalizeSeccionKey(s) {
    if (s === undefined || s === null) return null;
    const str = String(s).trim();
    if (str === '') return null;
    const digits = str.match(/\d+/g);
    if (digits && digits.length > 0) return digits.join('');
    return normalizeKey(str);
  }

  function normalizeMesKey(value) {
    if (value === undefined || value === null) return null;
    const text = String(value).trim().toLowerCase();
    if (!text || text === 'todos') return null;
    return text.split(' ')[0];
  }

  function getStatsCount(stats, filtroTipo, filtroEstado, filtroMes) {
    if (!stats) return 0;
    const tipo = filtroTipo && filtroTipo !== 'Todos' ? filtroTipo : null;
    const estado = filtroEstado && filtroEstado !== 'Todos' ? filtroEstado : null;
    const mes = normalizeMesKey(filtroMes);

    if (mes && tipo && estado) {
      return stats.mes_tipo_estado[`${mes}|${tipo}|${estado}`] || 0;
    }
    if (mes && tipo) {
      return stats.mes_tipo[`${mes}|${tipo}`] || 0;
    }
    if (mes && estado) {
      return stats.mes_estado[`${mes}|${estado}`] || 0;
    }
    if (tipo && estado) {
      return stats.tipo_estado[`${tipo}|${estado}`] || 0;
    }
    if (mes) {
      return stats.mes[mes] || 0;
    }
    if (tipo) {
      return stats.tipo[tipo] || 0;
    }
    if (estado) {
      return stats.estado[estado] || 0;
    }
    return stats.total || 0;
  }

  function getStatsByEstado(stats, filtroTipo, filtroEstado, filtroMes) {
    const result = {};
    const estados = (statsData && statsData.values && statsData.values.estado) ? statsData.values.estado : [];
    estados.forEach(est => {
      if (filtroEstado && filtroEstado !== 'Todos' && est !== filtroEstado) {
        result[est] = 0;
        return;
      }
      result[est] = getStatsCount(stats, filtroTipo, est, filtroMes);
    });
    return result;
  }

  function getStatsByTipo(stats, filtroTipo, filtroEstado, filtroMes) {
    const result = {};
    const tipos = (statsData && statsData.values && statsData.values.tipo) ? statsData.values.tipo : [];
    tipos.forEach(tipo => {
      if (filtroTipo && filtroTipo !== 'Todos' && tipo !== filtroTipo) {
        result[tipo] = 0;
        return;
      }
      result[tipo] = getStatsCount(stats, tipo, filtroEstado, filtroMes);
    });
    return result;
  }

  function buildEntityCounts(statsMap, filtroTipo, filtroEstado, filtroMes) {
    const counts = {};
    if (!statsMap) return counts;

    Object.keys(statsMap).forEach(key => {
      const entry = statsMap[key];
      counts[key] = {
        total: getStatsCount(entry, filtroTipo, filtroEstado, filtroMes),
        estados: getStatsByEstado(entry, filtroTipo, filtroEstado, filtroMes)
      };
    });

    return counts;
  }

  // ‚úÖ NUEVA OPTIMIZACI√ìN: Simplificar geometr√≠as de pol√≠gonos para reducir v√©rtices
  function simplifyGeometry(coords, tolerance = 0.001) {
    if (!coords || coords.length < 3) return coords;
    // Douglas-Peucker simplificado para reducir puntos en pol√≠gonos
    const simplified = [];
    const len = coords.length;
    // Siempre mantener primer y √∫ltimo punto
    simplified.push(coords[0]);
    // Tomar cada N puntos (m√°s agresivo en m√≥viles)
    const step = isMobile ? 3 : 2;
    for (let i = step; i < len - 1; i += step) {
      simplified.push(coords[i]);
    }
    simplified.push(coords[len - 1]);
    return simplified;
  }

  // ‚úÖ NUEVA OPTIMIZACI√ìN: Debounce para evitar m√∫ltiples renders r√°pidos
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // ========== OBTENER IDs FILTRADOS ==========
  // ‚úÖ OPTIMIZACI√ìN CR√çTICA: Usar √≠ndices por mes para filtrado S√öPER r√°pido
  function obtenerIdsFiltrados(filtroTipo, filtroEstado, filtroMes, ignoreColonia = false) {
    const filtroTipoVal = (filtroTipo === null || filtroTipo === undefined || filtroTipo === '') ? 'Todos' : filtroTipo;
    const filtroEstadoVal = (filtroEstado === null || filtroEstado === undefined || filtroEstado === '') ? 'Todos' : filtroEstado;
    const filtroMesVal = (filtroMes === null || filtroMes === undefined || filtroMes === '') ? 'Todos' : filtroMes;
    let setIds;
    
    // ‚úÖ FASE 1: FILTRAR POR MES (si aplica) - usando √≠ndices precomputados
    if (filtroMesVal !== "Todos") {
      const mesKey = String(filtroMesVal).toLowerCase();
      if (solicitudesPorMes[mesKey] && solicitudesPorMes[mesKey].ids && solicitudesPorMes[mesKey].ids.length > 0) {
        // ‚ö° Iniciar solo con IDs del mes (much√≠simo m√°s r√°pido)
        setIds = new Set(solicitudesPorMes[mesKey].ids);
        console.log(`‚ö° [INICIO] Filtro por mes "${mesKey}": ${setIds.size} solicitudes`);
      } else {
        // Fallback (no deber√≠a ocurrir si cargarMes() funciona bien)
        console.log('‚ö†Ô∏è Fallback: mes no encontrado en √≠ndices');
        setIds = new Set();
      }
    } else {
      // Todos los meses: usar allIds
      setIds = new Set(allIds);
      console.log(`‚ö° [INICIO] Sin filtro de mes: ${setIds.size} solicitudes totales`);
    }

    // ‚úÖ FASE 2: FILTRAR POR TIPO (si aplica)
    if (filtroTipoVal !== "Todos") {
      if (filtroMesVal !== "Todos") {
        // Usar √≠ndice mes+tipo para m√°xima velocidad
        const mesKey = String(filtroMesVal).toLowerCase();
        const mesTipoKey = `${mesKey}:${filtroTipoVal}`;
        const idsMesTipo = indiceMesTipo[mesTipoKey];
        
        if (idsMesTipo && idsMesTipo.length > 0) {
          setIds = new Set(idsMesTipo);
          console.log(`  ‚ûú Filtro por tipo "${filtroTipoVal}": ${setIds.size} solicitudes`);
        } else {
          setIds = new Set();
          console.log(`  ‚ûú Tipo "${filtroTipoVal}" no encontrado en mes "${mesKey}"`);
          return [];
        }
      } else {
        // Sin filtro de mes: usar √≠ndice tipo tradicional
        const idsTipo = indiceTipo[filtroTipoVal] || [];
        setIds = new Set(idsTipo);
        console.log(`  ‚ûú Filtro por tipo "${filtroTipoVal}": ${setIds.size} solicitudes`);
      }
    }

    // ‚úÖ FASE 3: FILTRAR POR ESTADO (si aplica)
    if (filtroEstadoVal !== "Todos") {
      if (filtroMesVal !== "Todos") {
        // Usar √≠ndice mes+estado para m√°xima velocidad
        const mesKey = String(filtroMesVal).toLowerCase();
        const mesEstadoKey = `${mesKey}:${filtroEstadoVal}`;
        const idsMesEstado = indiceMesEstado[mesEstadoKey];
        
        if (idsMesEstado && idsMesEstado.length > 0) {
          const idsMesEstadoSet = new Set(idsMesEstado);
          const nextIds = new Set();
          setIds.forEach(id => {
            if (idsMesEstadoSet.has(id)) nextIds.add(id);
          });
          setIds = nextIds;
          console.log(`  ‚ûú Filtro por estado "${filtroEstadoVal}": ${setIds.size} solicitudes`);
        } else {
          setIds = new Set();
          console.log(`  ‚ûú Estado "${filtroEstadoVal}" no encontrado`);
          return [];
        }
      } else {
        // Sin filtro de mes: usar √≠ndice estado tradicional
        const idsEstado = indiceEstado[filtroEstadoVal] || [];
        const idsEstadoSet = new Set(idsEstado);
        const nextIds = new Set();
        setIds.forEach(id => {
          if (idsEstadoSet.has(id)) nextIds.add(id);
        });
        setIds = nextIds;
        console.log(`  ‚ûú Filtro por estado "${filtroEstadoVal}": ${setIds.size} solicitudes`);
      }
    }

    // ‚úÖ FASE 4: FILTROS FINALES (colonia, secci√≥n)
    if (!ignoreColonia && coloniaSeleccionada) {
      const nombreColonia = coloniaSeleccionada.feature?.properties?.NOMBRE;
      const nombreNorm = normalizeKey(nombreColonia);
      setIds = new Set([...setIds].filter(id => solicitudPorId[id]["ColoniaNorm"] === nombreNorm));
      console.log(`üèòÔ∏è Filtro por colonia: ${setIds.size} solicitudes`);
    }
    
    if (!ignoreColonia && seccionSeleccionada) {
      const seccion = seccionSeleccionada.feature?.properties?.seccion || seccionSeleccionada.feature?.properties?.SECCION;
      if (seccion) {
        const seccionStr = String(seccion).trim();
        const seccionKey = normalizeSeccionKey(seccionStr);
        setIds = new Set([...setIds].filter(id => {
          const s = solicitudPorId[id];
          const sSec = s.seccion || s.SECCION;
          if (!sSec) return false;
          const sKey = normalizeSeccionKey(sSec);
          return sKey && seccionKey && sKey === seccionKey;
        }));
        console.log(`üó∫Ô∏è Filtro por secci√≥n: ${setIds.size} solicitudes`);
      }
    }

    console.log(`‚úÖ Total IDs filtrados: ${setIds.size}`);
    return [...setIds];
  }

  // ========== LOADING OVERLAY HELPERS ==========
  function showLoading() {
    try {
      const d = document.getElementById('loadingOverlay');
      if (d) {
        d.style.display = 'flex';
        d.style.visibility = 'visible';
        console.log('‚úÖ Loading overlay mostrado');
      }
    } catch (e) { console.log('showLoading error', e); }
  }
  function hideLoading() {
    try {
      const d = document.getElementById('loadingOverlay');
      if (d) {
        d.style.display = 'none';
        d.style.visibility = 'hidden';
        console.log('‚úÖ Loading overlay ocultado');
      }
    } catch (e) { console.log('hideLoading error', e); }
  }

  // ========== PREC√ÅLCULO DE √çNDICES Y ESTAD√çSTICAS ==========
  function precalcularIndices() {
    solicitudPorId = {};
    allIds = [];
    indiceTipo = {};
    indiceEstado = {};
    indiceMes = {};
    estadisticasPorColonia = {};
    coordIndexMap.clear(); // Limpiar √≠ndice espacial
    
    // IMPORTANTE: Ya tenemos indiceMesTipo e indiceMesEstado del cargarMes()
    // Aqu√≠ construimos los √≠ndices GLOBALES (sin mes)

    solicitudes.forEach((s, idx) => {
      s._id = idx;
      solicitudPorId[idx] = s;
      allIds.push(idx);

      // ‚úÖ NUEVA OPTIMIZACI√ìN: Construir √≠ndice espacial
      const lon = Number(s["Coordenada X"]);
      const lat = Number(s["Coordenada Y"]);
      if (!isNaN(lon) && !isNaN(lat)) {
        // Redondear a 6 decimales para agrupaci√≥n (~10cm precisi√≥n)
        const key = `${lon.toFixed(6)},${lat.toFixed(6)}`;
        if (!coordIndexMap.has(key)) coordIndexMap.set(key, []);
        coordIndexMap.get(key).push(idx);
      }

      const tipo = s["Tipo de reporte"] || "Sin tipo";
      if (!indiceTipo[tipo]) indiceTipo[tipo] = [];
      indiceTipo[tipo].push(idx);

      const estado = s["Estado Reporte"] || "Sin estado";
      if (!indiceEstado[estado]) indiceEstado[estado] = [];
      indiceEstado[estado].push(idx);

      if (s["Fecha reporte"]) {
        const fecha = new Date(s["Fecha reporte"]);
        if (!isNaN(fecha)) {
          const mesNombre = fecha.toLocaleString('es-ES', { month: 'long' });
          if (!indiceMes[mesNombre]) indiceMes[mesNombre] = [];
          indiceMes[mesNombre].push(idx);
        }
      }

      const col = s["Colonia"];
      const colNorm = s["ColoniaNorm"] || normalizeKey(col);
      if (colNorm) {
        if (!estadisticasPorColonia[colNorm]) {
          estadisticasPorColonia[colNorm] = { tipos: {}, estados: {}, meses: {}, originalNames: {} };
        }
        estadisticasPorColonia[colNorm].tipos[tipo] = (estadisticasPorColonia[colNorm].tipos[tipo] || 0) + 1;
        estadisticasPorColonia[colNorm].estados[estado] = (estadisticasPorColonia[colNorm].estados[estado] || 0) + 1;
        if (s["Fecha reporte"] && !isNaN(new Date(s["Fecha reporte"]))) {
          const mesNombre = new Date(s["Fecha reporte"]).toLocaleString('es-ES', { month: 'long' });
          estadisticasPorColonia[colNorm].meses[mesNombre] = (estadisticasPorColonia[colNorm].meses[mesNombre] || 0) + 1;
        }
        // Guardar ejemplos de nombres originales para referencia
        if (col) {
          estadisticasPorColonia[colNorm].originalNames[col] = (estadisticasPorColonia[colNorm].originalNames[col] || 0) + 1;
        }
      }
    });
    
    console.log('‚úÖ √çndice espacial construido con', coordIndexMap.size, 'ubicaciones √∫nicas');
    console.log('‚úÖ √çndices precalculados para', allIds.length, 'solicitudes');
    console.log('üìä √çndices de tipo:', Object.keys(indiceTipo).length);
    console.log('üìä √çndices de estado:', Object.keys(indiceEstado).length);
  }

  // ========== CONTROLES DE CAPAS CON SIMBOLOG√çA DESPLEGABLE ==========
  function agregarControlesCapas() {
    if (!map || !coloniasLayer || !seccionesLayer) return;

    var LayersControl = L.Control.extend({
      options: {
        position: 'topright'
      },
      onAdd: function (map) {
        var container = L.DomUtil.create('div', 'leaflet-control-layers-custom');
        container.style.backgroundColor = 'white';
        container.style.padding = '10px';
        container.style.borderRadius = '5px';
        container.style.boxShadow = '0 1px 5px rgba(0,0,0,0.4)';
        container.style.minWidth = '200px';
        container.style.maxWidth = '250px';
        
        var html = '<div style="font-weight:bold; margin-bottom:10px; color:#922B21; font-size:14px; border-bottom:2px solid #922B21; padding-bottom:5px;">üìç Control de Capas</div>';
        
        // Checkbox Colonias con bot√≥n de simbolog√≠a
        html += '<div style="margin-bottom:8px;">';
        html += '<div style="display:flex; align-items:center; justify-content:space-between;">';
        html += '<label style="cursor:pointer; display:flex; align-items:center; font-size:12px; flex:1;">';
        html += '<input type="checkbox" id="checkColonias" checked style="margin-right:8px; cursor:pointer;">';
        html += '<span>üèòÔ∏è Colonias</span>';
        html += '</label>';
        html += '<button id="btnSimColonias" style="background:#922B21; color:white; border:none; padding:2px 8px; border-radius:3px; cursor:pointer; font-size:10px;">Simbolog√≠a</button>';
        html += '</div>';
        html += '<div id="simbologiaColonias" style="display:none; margin-top:5px; padding:8px; background:#f9f9f9; border-radius:3px; font-size:10px;"></div>';
        html += '</div>';
        
        // Checkbox Secciones con bot√≥n de simbolog√≠a
        html += '<div style="margin-bottom:8px;">';
        html += '<div style="display:flex; align-items:center; justify-content:space-between;">';
        html += '<label style="cursor:pointer; display:flex; align-items:center; font-size:12px; flex:1;">';
        html += '<input type="checkbox" id="checkSecciones" style="margin-right:8px; cursor:pointer;">';
        html += '<span>üó∫Ô∏è Secciones</span>';
        html += '</label>';
        html += '<button id="btnSimSecciones" style="background:#922B21; color:white; border:none; padding:2px 8px; border-radius:3px; cursor:pointer; font-size:10px;">Simbolog√≠a</button>';
        html += '</div>';
        html += '<div id="simbologiaSecciones" style="display:none; margin-top:5px; padding:8px; background:#f9f9f9; border-radius:3px; font-size:10px;"></div>';
        html += '</div>';
        
        container.innerHTML = html;
        
        // Prevenir propagaci√≥n de eventos
        L.DomEvent.disableClickPropagation(container);
        L.DomEvent.disableScrollPropagation(container);
        
        return container;
      },
      
      onRemove: function(map) {
        // Cleanup
      }
    });

    var layersControl = new LayersControl();
    map.addControl(layersControl);
    
    // Event listeners
    setTimeout(function() {
      var checkColonias = document.getElementById('checkColonias');
      var checkSecciones = document.getElementById('checkSecciones');
      var btnSimColonias = document.getElementById('btnSimColonias');
      var btnSimSecciones = document.getElementById('btnSimSecciones');
      var divSimColonias = document.getElementById('simbologiaColonias');
      var divSimSecciones = document.getElementById('simbologiaSecciones');
      
      if (checkColonias) {
        checkColonias.addEventListener('change', function() {
          if (this.checked) {
            if (!map.hasLayer(coloniasLayer)) {
              coloniasLayer.addTo(map);
              showColonias = true;
              console.log('‚úÖ Colonias activadas');
            }
          } else {
            if (map.hasLayer(coloniasLayer)) {
              map.removeLayer(coloniasLayer);
              showColonias = false;
              if (divSimColonias) divSimColonias.style.display = 'none';
            }
          }
        });
      }
      
      if (checkSecciones) {
        checkSecciones.addEventListener('change', function() {
          console.log("üîÑ Checkbox secciones cambiado. Checked:", this.checked);
          
          if (this.checked) {
            if (!map.hasLayer(seccionesLayer)) {
              console.log("‚ûï Agregando seccionesLayer al mapa...");
              seccionesLayer.addTo(map);
              showSecciones = true;
              
              console.log('‚úÖ Secciones agregadas. Total layers en mapa:', Object.keys(map._layers).length);
              console.log('üó∫Ô∏è seccionesLayer visible:', map.hasLayer(seccionesLayer));
              console.log('üìç Bounds:', seccionesLayer.getBounds());
              
              // ‚úÖ NO ocultar loading aqu√≠ - dejar que renderizar() controle el timing
              // try { hideLoading(); } catch(e) { console.log("hideLoading no disponible"); }
              
              // Forzar refresco del mapa
              map.invalidateSize();
              
              // Forzar renderizado con estilos correctos despu√©s de un delay
              setTimeout(function() {
                try {
                  const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
                  const estado = document.getElementById('filtroEstado')?.value || 'Todos';
                  const mes = document.getElementById('filtroMes')?.value || 'Todos';
                  console.log('üîÑ Aplicando renderizado con filtros:', tipo, estado, mes);
                  renderizar(tipo, estado, mes);
                } catch (e) {
                  console.error('‚ùå Error al renderizar secciones:', e);
                }
              }, 100);
            }
          } else {
            console.log("‚ûñ Removiendo seccionesLayer del mapa...");
            if (map.hasLayer(seccionesLayer)) {
              map.removeLayer(seccionesLayer);
              showSecciones = false;
              if (divSimSecciones) divSimSecciones.style.display = 'none';
              console.log('‚úÖ Secciones removidas');
            }
          }
        });
      }
      
      // Botones de simbolog√≠a
      if (btnSimColonias && divSimColonias) {
        btnSimColonias.addEventListener('click', function() {
          if (divSimColonias.style.display === 'none' || !divSimColonias.style.display) {
            divSimColonias.style.display = 'block';
            if (divSimSecciones) divSimSecciones.style.display = 'none';
          } else {
            divSimColonias.style.display = 'none';
          }
        });
      }
      
      if (btnSimSecciones && divSimSecciones) {
        btnSimSecciones.addEventListener('click', function() {
          if (divSimSecciones.style.display === 'none' || !divSimSecciones.style.display) {
            divSimSecciones.style.display = 'block';
            if (divSimColonias) divSimColonias.style.display = 'none';
          } else {
            divSimSecciones.style.display = 'none';
          }
        });
      }
    }, 500);
    
    console.log("‚úÖ Control de capas con simbolog√≠a agregado");
  }

  // ========== ACTUALIZAR SIMBOLOG√çA EN PANEL ==========
  function actualizarSimbologiaPanel(breaks, tipo) {
    var divId = tipo === 'colonias' ? 'simbologiaColonias' : 'simbologiaSecciones';
    var div = document.getElementById(divId);
    if (!div) return;
    
    if (!breaks || breaks.length === 0) {
      div.innerHTML = '<div style="color:#999; font-style:italic;">Sin datos para mostrar</div>';
      return;
    }
    
    var html = '<div style="font-weight:bold; margin-bottom:5px; color:#922B21;">Natural Breaks (Jenks)</div>';
    
    for (var i = 0; i < breaks.length; i++) {
      var color = classColor(i);
      var rangoInicio = i === 0 ? 1 : Math.floor(breaks[i-1]) + 1;
      var rangoFin = Math.floor(breaks[i]);
      
      html += '<div style="display:flex; align-items:center; margin-bottom:3px;">';
      html += '<div style="width:20px; height:15px; background:' + color + '; border:1px solid #555; margin-right:5px;"></div>';
      html += '<span>' + rangoInicio + ' - ' + rangoFin + '</span>';
      html += '</div>';
    }
    
    div.innerHTML = html;
  }

  // ========== RENDERIZAR FUNCI√ìN OPTIMIZADA ==========
  function renderizar(filtroTipo, filtroEstado, filtroMes) {
    console.log('üöÄüöÄüöÄ RENDERIZAR LLAMADO üöÄüöÄüöÄ', {filtroTipo, filtroEstado, filtroMes});

    if (isRendering) {
      pendingRenderArgs = { filtroTipo, filtroEstado, filtroMes };
      return;
    }

    isRendering = true;
    pendingRenderArgs = null;
    
    // Limpiar cache de Top 5 cuando cambian los filtros
    limpiarCacheTop5();
    
    // Mostrar overlay de carga al iniciar render
    try { showLoading(); } catch(e){}

    // Prevenir renderizado si no hay datos cargados
    if (!solicitudes || solicitudes.length === 0 || !solicitudesGeoJSON) {
      console.log('‚ö†Ô∏è Renderizado cancelado: datos no disponibles');
      console.log(`   solicitudes: ${solicitudes?.length || 0}, solicitudesGeoJSON: ${solicitudesGeoJSON ? 'S√ç' : 'NO'}`);
      isRendering = false; // ‚úÖ CRITICAL: liberar flag para permitir retry
      // ‚úÖ NO ocultar loading aqu√≠ - solo estamos esperando datos
      return;
    }
    
    // ‚úÖ OPTIMIZACI√ìN 1: Usar √≠ndices precalculados en lugar de .forEach()
    // idsFiltradosRespectCol: respetan la selecci√≥n de colonia (para puntos)
    const requierePuntos = showPuntos && puntosYaCargados;
    const idsFiltradosRespectCol = requierePuntos
      ? obtenerIdsFiltrados(filtroTipo, filtroEstado, filtroMes, false)
      : [];

    // ‚úÖ OPTIMIZACI√ìN: Usar estadisticas precalculadas si est√°n disponibles
    const useStats = statsData && statsLoaded;
    let countsByColNorm = useStats ? buildEntityCounts(statsData.colonias, filtroTipo, filtroEstado, filtroMes) : {};
    let countsBySeccionNorm = useStats ? buildEntityCounts(statsData.secciones, filtroTipo, filtroEstado, filtroMes) : {};
    var tipos = useStats ? getStatsByTipo(statsData.global, filtroTipo, filtroEstado, filtroMes) : {};
    var estados = useStats ? getStatsByEstado(statsData.global, filtroTipo, filtroEstado, filtroMes) : {};
    var fechas = {};

    if (!useStats) {
      const idsFiltradosIgnoreCol = obtenerIdsFiltrados(filtroTipo, filtroEstado, filtroMes, true);
      let seccionesEncontradas = 0;
      let solicitudesConSeccion = 0;
      const seccionesMuestra = new Set();

      idsFiltradosIgnoreCol.forEach(id => {
        const s = solicitudPorId[id];
        if (!s) return;

        const norm = s["ColoniaNorm"] || normalizeKey(s["Colonia"]);
        const estado = s["Estado Reporte"] || 'Sin estado';
        if (norm) {
          if (!countsByColNorm[norm]) countsByColNorm[norm] = { total: 0, estados: {} };
          countsByColNorm[norm].total += 1;
          countsByColNorm[norm].estados[estado] = (countsByColNorm[norm].estados[estado] || 0) + 1;
        }

        const seccion = s.seccion || s.SECCION;
        if (seccion) {
          const seccionStr = String(seccion).trim();
          solicitudesConSeccion++;
          if (seccionesMuestra.size < 10) seccionesMuestra.add(seccionStr);

          const normSecc = normalizeSeccionKey(seccionStr);
          if (!countsBySeccionNorm[normSecc]) {
            countsBySeccionNorm[normSecc] = { total: 0, estados: {}, seccionOriginal: seccionStr };
            seccionesEncontradas++;
          }
          countsBySeccionNorm[normSecc].total += 1;
          countsBySeccionNorm[normSecc].estados[estado] = (countsBySeccionNorm[normSecc].estados[estado] || 0) + 1;
        }

        const tipo = s["Tipo de reporte"];
        const fecha = s["Fecha reporte"] ? new Date(s["Fecha reporte"]) : null;

        if (tipo) tipos[tipo] = (tipos[tipo] || 0) + 1;
        if (estado) {
          if (estado === "Pendiente" || estado === "En atenci√≥n") {
            estados["Pendiente/En Atenci√≥n"] = (estados["Pendiente/En Atenci√≥n"] || 0) + 1;
          } else {
            estados[estado] = (estados[estado] || 0) + 1;
          }
        }
        if (fecha && !isNaN(fecha)) {
          const clave = fecha.getFullYear() + "-" + (fecha.getMonth() + 1).toString().padStart(2, "0");
          fechas[clave] = (fechas[clave] || 0) + 1;
        }
      });

      console.log('üó∫Ô∏è Secciones procesadas:', seccionesEncontradas, 'unicas. Solicitudes con seccion:', solicitudesConSeccion);
      console.log('üîç Muestra de secciones en solicitudes:', Array.from(seccionesMuestra));
      console.log('üìä Ejemplo de normalizacion:', Object.keys(countsBySeccionNorm).slice(0, 5));
    }

    // ‚úÖ OPTIMIZACI√ìN 2: Filtrar GeoJSON una sola vez para los PUNTOS seg√∫n idsFiltradosRespectCol
    let featuresFiltradas = [];
    if (requierePuntos) {
      const allowedIds = new Set(idsFiltradosRespectCol);
      featuresFiltradas = solicitudesGeoJSON.features.filter((f, idx) => {
        if (!f.geometry || f.geometry.type !== "Point" || !Array.isArray(f.geometry.coordinates)) return false;

        // ‚úÖ MEJORA: Usar √≠ndice espacial para b√∫squeda r√°pida
        const lon = f.geometry.coordinates[0];
        const lat = f.geometry.coordinates[1];
        const key = `${lon.toFixed(6)},${lat.toFixed(6)}`;
        const idsEnCoordenada = coordIndexMap.get(key);

        if (!idsEnCoordenada) return false;

        // Verificar si alguno de los IDs en esta coordenada est√° en allowedIds
        return idsEnCoordenada.some(id => allowedIds.has(id));
      });
    }

    // ‚úÖ OPTIMIZACI√ìN 3: Inicializar capa de puntos UNA SOLA VEZ (sin clustering)
    if (!puntosLayer) {
      puntosLayer = L.layerGroup();
      // üî¥ NO AGREGAR AL MAPA INICIALMENTE - SOLO BAJO DEMANDA

      // ‚úÖ OPTIMIZACI√ìN 4: Event listener √öNICO para zoom
      if (!zoomendHandlerAdded) {
        map.on('zoomend', function() {
          if (!puntosLayer) return;
          // Mostrar puntos solo en zoom >= 16 y si showPuntos est√° activo Y fueron cargados
          if (map.getZoom() >= 16 && showPuntos && puntosYaCargados) {
            if (!map.hasLayer(puntosLayer)) map.addLayer(puntosLayer);
          } else {
            if (map.hasLayer(puntosLayer)) map.removeLayer(puntosLayer);
          }
        });
        zoomendHandlerAdded = true;
      }
    }

      // Asegurar control de leyenda y toggle est√°n creados
      if (!legendControl || !puntosToggleControl) createMapControls();

    // ‚ö†Ô∏è IMPORTANTE: SOLO cargar puntos si AMBAS condiciones se cumplen:
    //   1) showPuntos est√° HABILITADO
    //   2) puntosYaCargados es TRUE (usuario hizo click en el ojo)
    if (showPuntos && puntosYaCargados) {
      // ‚úÖ LIMPIAR layers de la capa anterior (sin recrear)
      puntosLayer.clearLayers();

      // ‚úÖ Agregar features filtradas
      const capaGeoJson = L.geoJson(
        { type: "FeatureCollection", features: featuresFiltradas },
        {
          pointToLayer: function (feature, latlng) {
            return L.circleMarker(latlng, {
              radius: 4,
              fillColor: "#F7EC1B",
              color: "#26261C",
              weight: 1,
              opacity: 1,
              fillOpacity: 0.7
            }).bindPopup(`
              <b>Folio:</b> ${feature.properties["N√∫mero folio"]}<br>
              <b>Ciudadano:</b> ${feature.properties["Nombre Ciudadano"] || 'N/A'}<br>
              <b>Tel√©fono:</b> ${feature.properties["Tel√©fono"] || 'N/A'}<br>
              <b>Tipo:</b> ${feature.properties["Tipo de reporte"]}<br>
              <b>Estado:</b> ${feature.properties["Estado Reporte"]}<br>
              <b>Punto de referencia:</b> ${feature.properties["Punto de referencia"] || 'N/A'}
            `);
          }
        }
      );

      puntosLayer.addLayer(capaGeoJson);
      
      // Mostrar puntos solo si: zoom >= 16
      const currentZoom = map.getZoom();
      if (currentZoom >= 16) {
        if (!map.hasLayer(puntosLayer)) map.addLayer(puntosLayer);
        const btn = document.getElementById('btnTogglePuntos'); if (btn) btn.style.opacity = '1';
      } else {
        if (map.hasLayer(puntosLayer)) map.removeLayer(puntosLayer);
        const btn = document.getElementById('btnTogglePuntos'); 
        if (btn) btn.style.opacity = '0.4';
      }
    } else {
      // Si showPuntos es false O puntosYaCargados es false, no mostrar puntos
      if (map.hasLayer(puntosLayer)) map.removeLayer(puntosLayer);
      const btn = document.getElementById('btnTogglePuntos');
      if (btn) btn.style.opacity = '0.4';
    }

    // Fitear solo si hay colonia seleccionada
    if (coloniaSeleccionada && coloniaSeleccionada.getBounds) {
      try {
        map.fitBounds(coloniaSeleccionada.getBounds());
      } catch (e) {
        console.log("Error fitBounds:", e);
      }
    }

    // ========== GR√ÅFICAS ==========
    const chartLimit = modoIOSLigero ? 4 : (isMobile ? 6 : 10); // En iOS reducir carga inicial
    function prepararDatos(obj) {
      let arr = Object.entries(obj);
      arr.sort((a, b) => b[1] - a[1]);
      arr = arr.slice(0, chartLimit);
      return {
        labels: arr.map(e => e[0]),
        values: arr.map(e => e[1])
      };
    }

    let datosTipos = prepararDatos(tipos);
    let datosEstados = prepararDatos(estados);

    // Definir colores y orden de estados (para usar en m√∫ltiples gr√°ficas)
    const ordenEstados = ["Pendiente", "En atenci√≥n", "Atendido", "No compete"];
    const coloresEstados = {
      "Pendiente": "#991B02",
      "En atenci√≥n": "#ED8718",
      "Atendido": "#0BC700",
      "No compete": "#545454"
    };

    // ========== GR√ÅFICA MESES Y ESTADOS ==========
    let mesesEstados = {};
    let mesesOrdenados = [];
    let labelsOrdenados = [];
    let totalsPorMes = [];
    let datasetsMeses = [];

    if (useStats) {
      const nombresMeses = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
                            'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
      const mesesBase = (statsData && statsData.values && statsData.values.mes) ? statsData.values.mes : [];
      const mesFiltro = normalizeMesKey(filtroMes);
      
      // Ordenar meses cronol√≥gicamente: junio, julio, ... enero
      const ordenMesesCronoLogico = ['junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre', 'enero', 'febrero', 'marzo', 'abril', 'mayo'];
      const mesesBaseOrdenados = mesesBase.sort((a, b) => {
        const idxA = ordenMesesCronoLogico.indexOf(a.toLowerCase());
        const idxB = ordenMesesCronoLogico.indexOf(b.toLowerCase());
        return (idxA === -1 ? 999 : idxA) - (idxB === -1 ? 999 : idxB);
      });

      mesesBaseOrdenados.forEach(mes => {
        if (mesFiltro && mes !== mesFiltro) return;
        const idx = ['enero','febrero','marzo','abril','mayo','junio','julio','agosto','septiembre','octubre','noviembre','diciembre'].indexOf(mes);
        mesesOrdenados.push(mes);
        mesesEstados[mes] = { label: idx >= 0 ? nombresMeses[idx] : mes, estados: {} };
        ordenEstados.forEach(est => {
          if (filtroEstado && filtroEstado !== 'Todos' && est !== filtroEstado) {
            mesesEstados[mes].estados[est] = 0;
          } else {
            const key = `${mes}|${filtroTipo}|${est}`;
            const val = (filtroTipo && filtroTipo !== 'Todos')
              ? (statsData.global.mes_tipo_estado[key] || 0)
              : (statsData.global.mes_estado[`${mes}|${est}`] || 0);
            mesesEstados[mes].estados[est] = val;
          }
        });
      });

      labelsOrdenados = mesesOrdenados.map(clave => mesesEstados[clave].label);
      totalsPorMes = mesesOrdenados.map(clave =>
        Object.values(mesesEstados[clave].estados || {}).reduce((a, b) => a + b, 0)
      );

      datasetsMeses = ordenEstados.map(est => ({
        label: est,
        data: mesesOrdenados.map(clave => mesesEstados[clave].estados[est] || 0),
        backgroundColor: coloresEstados[est] || "#999"
      }));
    } else {
      const idsFiltradosIgnoreCol = obtenerIdsFiltrados(filtroTipo, filtroEstado, filtroMes, true);
      const mesesClaves = new Set();
      idsFiltradosIgnoreCol.forEach(id => {
        const s = solicitudPorId[id];
        if (!s || !s["Fecha reporte"]) return;
        const fecha = new Date(s["Fecha reporte"]);
        if (isNaN(fecha)) return;
        const mesClave = fecha.getFullYear() + "-" + (fecha.getMonth() + 1).toString().padStart(2, "0");
        const nombresMeses = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
                              'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
        const mesLabel = nombresMeses[fecha.getMonth()] + " " + fecha.getFullYear();
        const estado = s["Estado Reporte"] || 'Sin estado';

        mesesClaves.add(mesClave);
        if (!mesesEstados[mesClave]) {
          mesesEstados[mesClave] = { label: mesLabel, estados: {} };
        }
        mesesEstados[mesClave].estados[estado] = (mesesEstados[mesClave].estados[estado] || 0) + 1;
      });

      // Ordenar por fecha cronol√≥gica ASCENDENTE (junio 2025 primero, enero 2026 √∫ltimo)
      mesesOrdenados = Array.from(mesesClaves).sort((a, b) => {
        const [yearA, monthA] = a.split('-').map(Number);
        const [yearB, monthB] = b.split('-').map(Number);
        if (yearA !== yearB) return yearA - yearB;  // Ascendente
        return monthA - monthB;  // Ascendente
      });
      labelsOrdenados = mesesOrdenados.map(clave => mesesEstados[clave].label);
      totalsPorMes = mesesOrdenados.map(clave =>
        Object.values(mesesEstados[clave].estados || {}).reduce((a, b) => a + b, 0)
      );
      datasetsMeses = ordenEstados.map(est => ({
        label: est,
        data: mesesOrdenados.map(clave => mesesEstados[clave].estados[est] || 0),
        backgroundColor: coloresEstados[est] || "#999"
      }));
    }

    if (chartMesesEstados) {
      chartMesesEstados.data.labels = labelsOrdenados;
      chartMesesEstados.data.datasets = datasetsMeses;
      chartMesesEstados.data.totals = totalsPorMes;
      chartMesesEstados.update(isMobile ? 'none' : 'none');
    } else {
      chartMesesEstados = new Chart(document.getElementById('chartMesesEstados'), {
        type: 'bar',
        data: {
          labels: labelsOrdenados,
          datasets: datasetsMeses,
          totals: totalsPorMes
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: 0 },
          layout: { padding: { right: 50 } },
          plugins: {
            title: {
              display: true,
              text: 'Solicitudes por Mes y Estado',
              font: { size: 14, weight: 'bold' },
              color: '#922B21',
              padding: { bottom: 10 }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const total = context.chart.data.totals[context.dataIndex];
                  const valor = context.raw;
                  return `${context.dataset.label}: ${valor} de ${total}`;
                }
              }
            },
            legend: { position: 'bottom', labels: { font: { size: 10 } } },
            datalabels: {
              display: function(context) {
                if (modoIOSLigero) return false;
                // Solo mostrar en el √∫ltimo segmento (No compete)
                return context.datasetIndex === context.chart.data.datasets.length - 1;
              },
              anchor: 'end',
              align: 'end',
              formatter: function(value, context) {
                const total = context.chart.data.totals[context.dataIndex];
                return total.toLocaleString('es-MX');
              },
              color: '#333',
              font: { weight: 'bold', size: 10 }
            }
          },
          scales: {
            x: { stacked: true, ticks: { precision: 0 } },
            y: {
              stacked: true,
              ticks: { font: { size: 9 } },
              maxRotation: 0,
              minRotation: 0,
              categoryPercentage: 0.7,
              barPercentage: 0.8
            }
          }
        },
        plugins: [ChartDataLabels]
      });
    }

    // Gr√°fica Tipos
    if (chartTipos) {
      chartTipos.data.labels = datosTipos.labels;
      chartTipos.data.datasets[0].data = datosTipos.values;
      chartTipos.update(isMobile ? 'none' : 'none');
    } else {
      chartTipos = new Chart(document.getElementById('chartTipos'), {
        type: 'bar',
        data: {
          labels: datosTipos.labels,
          datasets: [{
            label: 'Solicitudes por tipo',
            data: datosTipos.values,
            backgroundColor: '#922B21'
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: isMobile ? 0 : 0 },
          layout: { padding: { right: 50 } },
          plugins: {
            title: {
              display: true,
              text: 'Solicitudes por Tipo de Reporte',
              font: { size: 14, weight: 'bold' },
              color: '#922B21',
              padding: { bottom: 10 }
            },
            legend: { display: false },
            datalabels: {
              display: !modoIOSLigero,
              anchor: 'end',
              align: 'end',
              formatter: (value) => value.toLocaleString('es-MX'),
              color: '#333',
              font: { weight: 'bold', size: 11 }
            }
          },
          scales: {
            x: { ticks: { precision: 0 } },
            y: {
              ticks: { font: { size: 10 } },
              categoryPercentage: 0.7,
              barPercentage: 0.8
            }
          }
        },
        plugins: [ChartDataLabels]
      });
    }

    // Gr√°fica Colonias (usar countsByColNorm calculados desde idsFiltrados)
    const conteoColoniasEstados = {};
    Object.entries(countsByColNorm).forEach(([colNorm, info]) => {
      const displayName = normToColoniaName[colNorm] || (estadisticasPorColonia[colNorm] && Object.keys(estadisticasPorColonia[colNorm].originalNames || {})[0]) || colNorm;
      conteoColoniasEstados[displayName] = info.estados || {};
      conteoColoniasEstados[displayName]._total = info.total || 0;
    });

    let coloniasOrdenadas = Object.entries(conteoColoniasEstados)
      .map(([colonia, estados]) => {
        const total = estados._total || Object.values(estados).reduce((a, b) => a + b, 0);
        // remove _total from estados copy
        const estadosCopy = Object.assign({}, estados);
        delete estadosCopy._total;
        return { colonia, estados: estadosCopy, total };
      })
      .sort((a, b) => b.total - a.total)
      .slice(0, chartLimit);

    const labelsColonias = coloniasOrdenadas.map(c => c.colonia);
    const totalsColonias = coloniasOrdenadas.map(c => c.total);

    const datasetsColonias = ordenEstados.map(est => ({
      label: est,
      data: coloniasOrdenadas.map(c => c.estados[est] || 0),
      backgroundColor: coloresEstados[est] || "#999"
    }));

    if (chartColonias) {
      chartColonias.data.labels = labelsColonias;
      chartColonias.data.datasets = datasetsColonias;
      chartColonias.data.totals = totalsColonias;
      chartColonias.update(isMobile ? 'none' : 'none');
    } else {
      chartColonias = new Chart(document.getElementById('chartColonias'), {
        type: 'bar',
        data: {
          labels: labelsColonias,
          datasets: datasetsColonias,
          totals: totalsColonias
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: 0 },
          layout: { padding: { right: 50 } },
          plugins: {
            title: {
              display: true,
              text: 'Solicitudes por Colonia y Estado',
              font: { size: 14, weight: 'bold' },
              color: '#922B21',
              padding: { bottom: 10 }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const total = context.chart.data.totals[context.dataIndex];
                  const valor = context.raw;
                  return `${context.dataset.label}: ${valor} de ${total}`;
                }
              }
            },
            legend: { position: 'bottom', labels: { font: { size: 10 } } },
            datalabels: {
              display: function(context) {
                if (modoIOSLigero) return false;
                // Solo mostrar en el √∫ltimo segmento (No compete)
                return context.datasetIndex === context.chart.data.datasets.length - 1;
              },
              anchor: 'end',
              align: 'end',
              formatter: function(value, context) {
                const total = context.chart.data.totals[context.dataIndex];
                return total.toLocaleString('es-MX');
              },
              color: '#333',
              font: { weight: 'bold', size: 10 }
            }
          },
          scales: {
            x: { stacked: true, ticks: { precision: 0 } },
            y: {
              stacked: true,
              ticks: { font: { size: 9 } },
              maxRotation: 0,
              minRotation: 0,
              categoryPercentage: 0.7,
              barPercentage: 0.8
            }
          }
        },
        plugins: [ChartDataLabels]
      });
    }

    // Gr√°fica Estados
    if (chartEstados) {
      chartEstados.data.labels = datosEstados.labels;
      chartEstados.data.datasets[0].data = datosEstados.values;
      chartEstados.update(isMobile ? 'none' : 'none');
    } else {
      chartEstados = new Chart(document.getElementById('chartEstados'), {
        type: 'bar',
        data: {
          labels: datosEstados.labels,
          datasets: [{
            label: 'Solicitudes por estado',
            data: datosEstados.values,
            backgroundColor: '#36a2eb'
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: isMobile ? 0 : 0 },
          layout: { padding: { right: 50 } },
          plugins: {
            title: {
              display: true,
              text: 'Solicitudes por Estado',
              font: { size: 14, weight: 'bold' },
              color: '#922B21',
              padding: { bottom: 10 }
            },
            legend: { display: false },
            datalabels: {
              display: !modoIOSLigero,
              anchor: 'end',
              align: 'end',
              formatter: (value) => value.toLocaleString('es-MX'),
              color: '#333',
              font: { weight: 'bold', size: 11 }
            }
          },
          scales: {
            x: { ticks: { precision: 0 } },
            y: {
              ticks: { font: { size: 10 } },
              categoryPercentage: 0.7,
              barPercentage: 0.8
            }
          }
        },
        plugins: [ChartDataLabels]
      });
    }

    // ========== ACTUALIZAR CONTADOR DE SOLICITUDES ==========
    try {
      const filtroTipoLook = (filtroTipo === "Todos") ? null : filtroTipo;
      const filtroEstadoLook = (filtroEstado === "Todos") ? null : filtroEstado;
      const filtroMesLook = (filtroMes === "Todos") ? null : filtroMes;

      let totalSolicitudes = 0;

      if (statsData && statsLoaded) {
        totalSolicitudes = getStatsCount(statsData.global, filtroTipoLook, filtroEstadoLook, filtroMesLook);

        if (coloniaSeleccionada) {
          const nombreColonia = coloniaSeleccionada.feature?.properties?.NOMBRE;
          const nombreNorm = normalizeKey(nombreColonia);
          const entry = statsData.colonias && statsData.colonias[nombreNorm];
          if (entry) {
            totalSolicitudes = getStatsCount(entry, filtroTipoLook, filtroEstadoLook, filtroMesLook);
          }
        }
      } else {
        const idsFiltrados = obtenerIdsFiltrados(filtroTipoLook, filtroEstadoLook, filtroMesLook, false);
        let idsFiltradosConColonia = idsFiltrados;
        if (coloniaSeleccionada) {
          const nombreColonia = coloniaSeleccionada.feature?.properties?.NOMBRE;
          const nombreNorm = normalizeKey(nombreColonia);
          idsFiltradosConColonia = idsFiltrados.filter(id => {
            const s = solicitudPorId[id];
            return s && s["ColoniaNorm"] === nombreNorm;
          });
        }
        totalSolicitudes = idsFiltradosConColonia.length;
      }

      console.log(`‚ö° renderizar(): Solicitudes filtradas = ${totalSolicitudes}`);

      const totalSpan = document.getElementById('totalSolicitudes');
      if (totalSpan) {
        totalSpan.innerHTML = `<span style="font-size:1.1em">${totalSolicitudes.toLocaleString('es-MX')}</span>`;
      }

      if (modoIOSLigero) {
        const spanPrimarias = document.getElementById("vialidadesPrimarias");
        const spanLocales = document.getElementById("vialidadesLocales");

        if (statsData?.meta?.vialidades) {
          if (spanPrimarias) spanPrimarias.textContent = Number(statsData.meta.vialidades.primarias || 0).toLocaleString('es-MX');
          if (spanLocales) spanLocales.textContent = Number(statsData.meta.vialidades.locales || 0).toLocaleString('es-MX');
        }
      } else {

      // ========== CALCULAR VIALIDADES DIN√ÅMICAMENTE SEG√öN FILTROS ==========
      // Obtener IDs filtrados para calcular vialidades
      const idsFiltrados = obtenerIdsFiltrados(filtroTipoLook, filtroEstadoLook, filtroMesLook, false);
      let idsFiltradosConColonia = idsFiltrados;
      if (coloniaSeleccionada) {
        const nombreColonia = coloniaSeleccionada.feature?.properties?.NOMBRE;
        const nombreNorm = normalizeKey(nombreColonia);
        idsFiltradosConColonia = idsFiltrados.filter(id => {
          const s = solicitudPorId[id];
          return s && s["ColoniaNorm"] === nombreNorm;
        });
      }

      if (showPuntos && puntosYaCargados) {
        if (totalSpan) {
          totalSpan.innerHTML = `<span style="font-size:1.1em">${totalSolicitudes.toLocaleString('es-MX')}</span> <span style="font-size:0.9em; color:#666;">(Calculando vialidades...)</span>`;
        }

        setTimeout(() => {
          let enVialidadesPrimarias = 0;

          if (vialidadesLayer) {
            const vialidadesGeoJSON = vialidadesLayer.toGeoJSON();
            idsFiltradosConColonia.forEach(id => {
              const s = solicitudPorId[id];
              if (!s) return;

              const lon = Number(s["Coordenada X"]);
              const lat = Number(s["Coordenada Y"]);
              if (!isNaN(lon) && !isNaN(lat)) {
                const punto = turf.point([lon, lat]);
                // Solo verificar contra vialidades PRIMARIAS
                for (let feature of vialidadesGeoJSON.features) {
                  const tipo = (feature.properties?.TIPO_VIA || feature.properties?.tipo_via || "").toLowerCase();
                  // Solo contar si es v√≠a primaria
                  if (tipo.includes("primaria")) {
                    // Manejar tanto Polygon como MultiPolygon
                    if (feature.geometry.type === "Polygon") {
                      if (turf.booleanPointInPolygon(punto, feature)) {
                        enVialidadesPrimarias++;
                        break;
                      }
                    } else if (feature.geometry.type === "MultiPolygon") {
                      // Para MultiPolygon, convertir cada pol√≠gono a una feature independiente
                      for (let polyCoords of feature.geometry.coordinates) {
                        const polyFeature = {
                          type: "Feature",
                          geometry: {
                            type: "Polygon",
                            coordinates: polyCoords
                          },
                          properties: feature.properties
                        };
                        if (turf.booleanPointInPolygon(punto, polyFeature)) {
                          enVialidadesPrimarias++;
                          break;
                        }
                      }
                      if (enVialidadesPrimarias > 0) break; // Ya encontr√≥ en este feature
                    }
                  }
                }
              }
            });
          }

          const enVialidadesLocales = totalSolicitudes - enVialidadesPrimarias;
          
          // Actualizar spans de vialidades
          const spanPrimarias = document.getElementById("vialidadesPrimarias");
          const spanLocales = document.getElementById("vialidadesLocales");
          if (spanPrimarias) spanPrimarias.textContent = enVialidadesPrimarias.toLocaleString('es-MX');
          if (spanLocales) spanLocales.textContent = enVialidadesLocales.toLocaleString('es-MX');
          
          if (totalSpan) {
            totalSpan.innerHTML = `<span style="font-size:1.1em">${totalSolicitudes.toLocaleString('es-MX')}</span> (Vialidades Primarias: <span style="font-size:1.1em">${enVialidadesPrimarias.toLocaleString('es-MX')}</span>, Vialidades Locales: <span style="font-size:1.1em">${enVialidadesLocales.toLocaleString('es-MX')}</span>)`;
          }
        }, 100);
      } else {
        // Incluso sin puntos visibles, calcular vialidades din√°micamente
        let enVialidadesPrimarias = 0;

        if (vialidadesLayer) {
          const vialidadesGeoJSON = vialidadesLayer.toGeoJSON();
          idsFiltradosConColonia.forEach(id => {
            const s = solicitudPorId[id];
            if (!s) return;

            const lon = Number(s["Coordenada X"]);
            const lat = Number(s["Coordenada Y"]);
            if (!isNaN(lon) && !isNaN(lat)) {
              const punto = turf.point([lon, lat]);
              // Solo verificar contra vialidades PRIMARIAS
              for (let feature of vialidadesGeoJSON.features) {
                const tipo = (feature.properties?.TIPO_VIA || feature.properties?.tipo_via || "").toLowerCase();
                // Solo contar si es v√≠a primaria
                if (tipo.includes("primaria")) {
                  // Manejar tanto Polygon como MultiPolygon
                  if (feature.geometry.type === "Polygon") {
                    if (turf.booleanPointInPolygon(punto, feature)) {
                      enVialidadesPrimarias++;
                      break;
                    }
                  } else if (feature.geometry.type === "MultiPolygon") {
                    // Para MultiPolygon, convertir cada pol√≠gono a una feature independiente
                    for (let polyCoords of feature.geometry.coordinates) {
                      const polyFeature = {
                        type: "Feature",
                        geometry: {
                          type: "Polygon",
                          coordinates: polyCoords
                        },
                        properties: feature.properties
                      };
                      if (turf.booleanPointInPolygon(punto, polyFeature)) {
                        enVialidadesPrimarias++;
                        break;
                      }
                    }
                    if (enVialidadesPrimarias > 0) break; // Ya encontr√≥ en este feature
                  }
                }
              }
            }
          });
        }

        const enVialidadesLocales = totalSolicitudes - enVialidadesPrimarias;
        
        // Actualizar spans de vialidades
        const spanPrimarias = document.getElementById("vialidadesPrimarias");
        const spanLocales = document.getElementById("vialidadesLocales");
        if (spanPrimarias) spanPrimarias.textContent = enVialidadesPrimarias.toLocaleString('es-MX');
        if (spanLocales) spanLocales.textContent = enVialidadesLocales.toLocaleString('es-MX');
      }
      }
    } catch (e) {
      console.log('Error actualizando contador:', e);
    }

    // ========== TABLA RESUMEN ==========
    // La tabla Top 10 se afecta por TODOS los filtros (Tipo, Estado y Mes) para coincidir con gr√°ficas
    // La tabla resumen SOLO se afecta por el filtro de Tipo (ignora Estado y Mes)
    try {
      if (isMobile) {
        // Aplazar tabla en m√≥viles para que gr√°ficas se rendericen primero
        setTimeout(() => {
          generarTablaTop10(filtroTipo, filtroEstado, filtroMes);
          generarTablaResumen(filtroTipo);
          generarTablaSecciones(filtroTipo);
        }, 100);
      } else {
        generarTablaTop10(filtroTipo, filtroEstado, filtroMes);
        generarTablaResumen(filtroTipo);
        generarTablaSecciones(filtroTipo);
      }
    } catch (e) {
      console.log('Error actualizando tablas:', e);
    }

    // ========== CHOROPLETH ==========
    if (coloniasLayer) {
      // Primero calcular total de solicitudes por colonia respetando filtros
      const totalsArr = [];
      const totalsByCol = {};

      // Obtener totals a partir de countsByColNorm (ya filtrados)
      coloniasLayer.eachLayer(layer => {
        const nombre = layer.feature.properties.NOMBRE;
        const nombreNorm = layer.feature.properties._normName || normalizeKey(nombre);
        const info = countsByColNorm[nombreNorm];
        const total = info ? info.total : 0;
        totalsByCol[nombre] = total;
        if (total > 0) totalsArr.push(total);
      });

      const numClasses = 5;
      if (totalsArr.length === 0) {
        // No hay datos: pintar todo gris claro
        coloniasLayer.eachLayer(layer => {
          try {
            layer.setStyle({ fillColor: "#eee", fillOpacity: 0.2, color: "#555", weight: 1 });
            const nombre = layer.feature.properties.NOMBRE;
            const total = totalsByCol[nombre] || 0;
            
            let popupContent = `<b>${nombre}</b><br>Total Solicitudes: ${total}`;
            
            if (total > 0) {
              const top5Tipos = getTop5TiposPorColonia(nombre, filtroTipo, filtroEstado, filtroMes);
              
              if (top5Tipos.length > 0) {
                const rows = top5Tipos.map(([tipo, datos]) => 
                  `<tr style="border-bottom:1px solid #ddd;">
                    <td style="padding:3px;">${tipo}</td>
                    <td style="padding:3px; text-align:center;">${datos.Pendiente}</td>
                    <td style="padding:3px; text-align:center;">${datos["En atenci√≥n"]}</td>
                    <td style="padding:3px; text-align:center;">${datos.Atendido}</td>
                    <td style="padding:3px; text-align:center;">${datos["No compete"]}</td>
                    <td style="padding:3px; text-align:center; font-weight:bold;">${datos.total}</td>
                  </tr>`
                ).join('');
                
                popupContent += `<br><br><strong>Top 5 Solicitudes:</strong>
                  <table style="font-size:10px; border-collapse:collapse; margin-top:5px; width:100%;">
                    <tr style="background:#922B21; color:white;">
                      <th style="padding:3px; text-align:left;">Tipo</th>
                      <th style="padding:3px;">Pendiente</th>
                      <th style="padding:3px;">En atenci√≥n</th>
                      <th style="padding:3px;">Atendido</th>
                      <th style="padding:3px;">No compete</th>
                      <th style="padding:3px;">Total</th>
                    </tr>
                    ${rows}
                  </table>`;
              }
            }
            
            layer.bindPopup(popupContent);
          } catch (e) {
            console.log("Error en choropleth (sin datos):", e);
          }
        });
      } else {
        // Calcular quiebres Jenks (manejar si hay menos valores que clases)
        const clases = Math.min(numClasses, totalsArr.length);
        let breaks = [];
        try {
          breaks = getJenksBreaks(totalsArr, clases);
        } catch (e) {
          console.log('Error calculando Jenks:', e);
          // fallback: usar percentiles simples
          totalsArr.sort((a,b)=>a-b);
          breaks = [];
          for (let i=1;i<=clases;i++) {
            const idx = Math.floor((totalsArr.length * i) / clases) - 1;
            breaks.push(totalsArr[Math.max(0, Math.min(totalsArr.length-1, idx))]);
          }
        }

        // Asegurar que los quiebres est√©n ordenados y sean √∫nicos
        breaks = Array.from(new Set(breaks)).sort((a,b)=>a-b);

        coloniasLayer.eachLayer(layer => {
          const nombre = layer.feature.properties.NOMBRE;
          const total = totalsByCol[nombre] || 0;

          let fill = "#eee";
          let opacity = 0.2;

          if (total > 0) {
            // Determinar clase: 0..(breaks.length-1)
            let cls = 0;
            for (let i = 0; i < breaks.length; i++) {
              if (total <= breaks[i]) { cls = i; break; }
              cls = i;
            }
            fill = classColor(cls);
            // mapear opacidad seg√∫n clase (m√°s solicitudes -> mayor opacidad)
            opacity = 0.35 + (cls / Math.max(1, breaks.length - 1)) * 0.55;
          }

          try {
            layer.setStyle({ fillColor: fill, fillOpacity: opacity, color: "#555", weight: 1 });
            
            // Generar contenido del popup con top 5 tipos
            let popupContent = `<b>${nombre}</b><br>Total Solicitudes: ${total}`;
            
            if (total > 0) {
              const top5Tipos = getTop5TiposPorColonia(nombre, filtroTipo, filtroEstado, filtroMes);
              
              if (top5Tipos.length > 0) {
                const rows = top5Tipos.map(([tipo, datos]) => 
                  `<tr style="border-bottom:1px solid #ddd;">
                    <td style="padding:3px;">${tipo}</td>
                    <td style="padding:3px; text-align:center;">${datos.Pendiente}</td>
                    <td style="padding:3px; text-align:center;">${datos["En atenci√≥n"]}</td>
                    <td style="padding:3px; text-align:center;">${datos.Atendido}</td>
                    <td style="padding:3px; text-align:center;">${datos["No compete"]}</td>
                    <td style="padding:3px; text-align:center; font-weight:bold;">${datos.total}</td>
                  </tr>`
                ).join('');
                
                popupContent += `<br><br><strong>Top 5 Solicitudes:</strong>
                  <table style="font-size:10px; border-collapse:collapse; margin-top:5px; width:100%;">
                    <tr style="background:#922B21; color:white;">
                      <th style="padding:3px; text-align:left;">Tipo</th>
                      <th style="padding:3px;">Pendiente</th>
                      <th style="padding:3px;">En atenci√≥n</th>
                      <th style="padding:3px;">Atendido</th>
                      <th style="padding:3px;">No compete</th>
                      <th style="padding:3px;">Total</th>
                    </tr>
                    ${rows}
                  </table>`;
              }
            }
            
            layer.bindPopup(popupContent);
          } catch (e) {
            console.log("Error en choropleth (pintado):", e);
          }
        });
        // Actualizar simbolog√≠a en panel con los quiebres calculados
        try { actualizarSimbologiaPanel(breaks, 'colonias'); } catch (e) { console.log('Error actualizando simbolog√≠a:', e); }
      }
    }
    else {
      // Si no hay coloniasLayer o sin datos, limpiar la simbolog√≠a
      try { actualizarSimbologiaPanel(null, 'colonias'); } catch(e){}
    }

    // ===== ACTUALIZAR ESTILOS DE SECCIONES =====
    if (seccionesLayer) {
      console.log('üîç Procesando secciones. Total secciones normalizadas:', Object.keys(countsBySeccionNorm).length);
      const totalsArrSecciones = [];
      const totalsBySeccion = {};
      const seccionesLayerMuestra = [];

      seccionesLayer.eachLayer(layer => {
        const seccion = layer.feature.properties.seccion || layer.feature.properties.SECCION;
        // Convertir a string para comparaci√≥n consistente
        const seccionStr = String(seccion).trim();
        const nombreNorm = layer.feature.properties._normName || normalizeSeccionKey(seccionStr);
        
        // Guardar muestra para debugging
        if (seccionesLayerMuestra.length < 5) {
          seccionesLayerMuestra.push({original: seccionStr, normalizado: nombreNorm});
        }
        
        const info = countsBySeccionNorm[nombreNorm];
        const total = info ? info.total : 0;
        totalsBySeccion[seccionStr] = total;
        if (total > 0) totalsArrSecciones.push(total);
      });
      
      console.log('üîç Muestra de secciones del layer:', seccionesLayerMuestra);
      console.log('üî¢ Ejemplo de totales:', Object.entries(totalsBySeccion).slice(0, 5));
      console.log('üìä Totales de secciones calculados:', totalsArrSecciones.length, 'secciones con datos');
      if (totalsArrSecciones.length > 0) {
        console.log('üìà Rango de totales:', Math.min(...totalsArrSecciones), '-', Math.max(...totalsArrSecciones));
      }

      const numClasses = 5;
      if (totalsArrSecciones.length === 0) {
        seccionesLayer.eachLayer(layer => {
          try {
            layer.setStyle({ fillColor: "#eee", fillOpacity: 0.2, color: "#555", weight: 1 });
            const seccion = layer.feature.properties.seccion || layer.feature.properties.SECCION;
            const seccionStr = String(seccion).trim();
            const total = totalsBySeccion[seccionStr] || 0;
            layer.bindPopup(`<b>Secci√≥n ${seccionStr}</b><br>Total Solicitudes: ${total}`);
          } catch (e) {
            console.log("Error en secciones (sin datos):", e);
          }
        });
        // Limpiar simbolog√≠a de secciones
        try { actualizarSimbologiaPanel(null, 'secciones'); } catch (e) {}
      } else {
        const clases = Math.min(numClasses, totalsArrSecciones.length);
        let breaks = [];
        try {
          breaks = getJenksBreaks(totalsArrSecciones, clases);
        } catch (e) {
          console.log('Error calculando Jenks para secciones:', e);
          totalsArrSecciones.sort((a,b)=>a-b);
          breaks = [];
          for (let i=1;i<=clases;i++) {
            const idx = Math.floor((totalsArrSecciones.length * i) / clases) - 1;
            breaks.push(totalsArrSecciones[Math.max(0, Math.min(totalsArrSecciones.length-1, idx))]);
          }
        }

        breaks = Array.from(new Set(breaks)).sort((a,b)=>a-b);

        seccionesLayer.eachLayer(layer => {
          const seccion = layer.feature.properties.seccion || layer.feature.properties.SECCION;
          const seccionStr = String(seccion).trim();
          const total = totalsBySeccion[seccionStr] || 0;

          let fill = "#eee";
          let opacity = 0.2;

          if (total > 0) {
            let cls = 0;
            for (let i = 0; i < breaks.length; i++) {
              if (total <= breaks[i]) { cls = i; break; }
              cls = i;
            }
            fill = classColor(cls);
            opacity = 0.35 + (cls / Math.max(1, breaks.length - 1)) * 0.55;
          }

          try {
            layer.setStyle({ fillColor: fill, fillOpacity: opacity, color: "#555", weight: 1 });
            
            let popupContent = `<b>Secci√≥n ${seccion}</b><br>Total Solicitudes: ${total}`;
            
            if (total > 0) {
              const top5Tipos = getTop5TiposPorSeccion(seccion, filtroTipo, filtroEstado, filtroMes);
              
              if (top5Tipos.length > 0) {
                const rows = top5Tipos.map(([tipo, datos]) => 
                  `<tr style="border-bottom:1px solid #ddd;">
                    <td style="padding:3px;">${tipo}</td>
                    <td style="padding:3px; text-align:center;">${datos.Pendiente}</td>
                    <td style="padding:3px; text-align:center;">${datos["En atenci√≥n"]}</td>
                    <td style="padding:3px; text-align:center;">${datos.Atendido}</td>
                    <td style="padding:3px; text-align:center;">${datos["No compete"]}</td>
                    <td style="padding:3px; text-align:center; font-weight:bold;">${datos.total}</td>
                  </tr>`
                ).join('');
                
                popupContent += `<br><br><strong>Top 5 Solicitudes:</strong>
                  <table style="font-size:10px; border-collapse:collapse; margin-top:5px; width:100%;">
                    <tr style="background:#922B21; color:white;">
                      <th style="padding:3px; text-align:left;">Tipo</th>
                      <th style="padding:3px;">Pendiente</th>
                      <th style="padding:3px;">En atenci√≥n</th>
                      <th style="padding:3px;">Atendido</th>
                      <th style="padding:3px;">No compete</th>
                      <th style="padding:3px;">Total</th>
                    </tr>
                    ${rows}
                  </table>`;
              }
            }
            
            layer.bindPopup(popupContent);
          } catch (e) {
            console.log("Error en secciones (pintado):", e);
          }
        });
        // Actualizar simbolog√≠a de secciones en panel
        try { actualizarSimbologiaPanel(breaks, 'secciones'); } catch (e) { console.log('Error actualizando simbolog√≠a secciones:', e); }
      }
    }

    // Ocultar overlay al terminar render - esperar a que TODA la renderizaci√≥n est√© completa
    try { 
      // Esperar tiempo significativo para que mapa, gr√°ficas y datos se carguen completamente
      setTimeout(function() {
        hideLoading();
        console.log('‚úÖ Renderizado completo. Loading oculto.');
      }, modoIOSLigero ? 2500 : (isMobile ? 8000 : 7000)); 
    } catch(e){
      console.log('‚ùå Error ocultando loading:', e);
    }

    isRendering = false;
    if (pendingRenderArgs) {
      const { filtroTipo: ft, filtroEstado: fe, filtroMes: fm } = pendingRenderArgs;
      pendingRenderArgs = null;
      if (typeof renderizarDebounced === 'function') {
        renderizarDebounced(ft, fe, fm);
      } else {
        setTimeout(() => renderizar(ft, fe, fm), 0);
      }
    }
  }

  // ========== FUNCI√ìN AUXILIAR: TOP 5 TIPOS POR COLONIA ==========
  // ========== FUNCI√ìN AUXILIAR: TOP 5 TIPOS POR COLONIA ==========
  const cacheTop5 = {}; // Cache para evitar recalcular
  
  function getTop5TiposPorColonia(nombreColonia, filtroTipo, filtroEstado, filtroMes) {
    // Crear clave √∫nica para el cache
    const cacheKey = `${nombreColonia}|${filtroTipo}|${filtroEstado}|${filtroMes}`;
    
    // Si ya est√° en cache, devolver inmediatamente
    if (cacheTop5[cacheKey]) {
      return cacheTop5[cacheKey];
    }
    
    const tiposPorEstado = {};

    if (statsData && statsLoaded) {
      const coloniaKey = normalizeKey(nombreColonia) || nombreColonia;
      const entry = statsData.colonias[coloniaKey];
      const tipos = (statsData.values && statsData.values.tipo) ? statsData.values.tipo : [];
      const estados = (statsData.values && statsData.values.estado) ? statsData.values.estado : [];

      tipos.forEach(tipo => {
        if (filtroTipo && filtroTipo !== 'Todos' && tipo !== filtroTipo) return;
        tiposPorEstado[tipo] = {
          total: 0,
          Pendiente: 0,
          "En atenci√≥n": 0,
          Atendido: 0,
          "No compete": 0
        };

        estados.forEach(estado => {
          if (filtroEstado && filtroEstado !== 'Todos' && estado !== filtroEstado) {
            return;
          }
          const mesKey = normalizeMesKey(filtroMes);
          let count = 0;
          if (entry) {
            if (mesKey) {
              count = entry.mes_tipo_estado[`${mesKey}|${tipo}|${estado}`] || 0;
            } else if (filtroTipo && filtroEstado && filtroTipo !== 'Todos' && filtroEstado !== 'Todos') {
              count = entry.tipo_estado[`${tipo}|${estado}`] || 0;
            } else {
              count = entry.tipo_estado[`${tipo}|${estado}`] || 0;
            }
          }

          tiposPorEstado[tipo][estado] = (tiposPorEstado[tipo][estado] || 0) + count;
          tiposPorEstado[tipo].total += count;
        });
      });
    } else {
      // ‚úÖ OPTIMIZACI√ìN CR√çTICA: Usar obtenerIdsFiltrados() en lugar de iterar todo solicitudes
      const idsFiltrados = obtenerIdsFiltrados(filtroTipo, filtroEstado, filtroMes, true);
      
      idsFiltrados.forEach(id => {
        const s = solicitudPorId[id];
        if (!s || !s.Colonia || !s.ColoniaNorm) return;
        
        // Comparar usando el diccionario normToColoniaName
        const nombreColoniaDesdeNorm = normToColoniaName[s.ColoniaNorm];
        
        if (nombreColoniaDesdeNorm === nombreColonia && s["Tipo de reporte"] && s["Estado Reporte"]) {
          const tipo = s["Tipo de reporte"];
          const estado = s["Estado Reporte"];
          
          if (!tiposPorEstado[tipo]) {
            tiposPorEstado[tipo] = {
              total: 0,
              Pendiente: 0,
              "En atenci√≥n": 0,
              Atendido: 0,
              "No compete": 0
            };
          }
          
          tiposPorEstado[tipo].total++;
          tiposPorEstado[tipo][estado] = (tiposPorEstado[tipo][estado] || 0) + 1;
        }
      });
    }
    
    // Ordenar por total y tomar top 5
    const top5 = Object.entries(tiposPorEstado)
      .sort((a, b) => b[1].total - a[1].total)
      .slice(0, 5);
    
    // Guardar en cache
    cacheTop5[cacheKey] = top5;
    
    return top5;
  }
  
  // Limpiar cache cuando cambian los filtros
  function limpiarCacheTop5() {
    for (let key in cacheTop5) {
      delete cacheTop5[key];
    }
    for (let key in cacheTop5Secciones) {
      delete cacheTop5Secciones[key];
    }
  }

  // ========== FUNCI√ìN AUXILIAR: TOP 5 TIPOS POR SECCI√ìN ==========
  const cacheTop5Secciones = {}; // Cache separado para secciones
  
  function getTop5TiposPorSeccion(seccion, filtroTipo, filtroEstado, filtroMes) {
    const cacheKey = `${seccion}|${filtroTipo}|${filtroEstado}|${filtroMes}`;
    
    if (cacheTop5Secciones[cacheKey]) {
      return cacheTop5Secciones[cacheKey];
    }
    
    const tiposPorEstado = {};

    if (statsData && statsLoaded) {
      const seccionKey = normalizeSeccionKey(seccion);
      const entry = statsData.secciones[seccionKey];
      const tipos = (statsData.values && statsData.values.tipo) ? statsData.values.tipo : [];
      const estados = (statsData.values && statsData.values.estado) ? statsData.values.estado : [];

      tipos.forEach(tipo => {
        if (filtroTipo && filtroTipo !== 'Todos' && tipo !== filtroTipo) return;
        tiposPorEstado[tipo] = {
          total: 0,
          Pendiente: 0,
          "En atenci√≥n": 0,
          Atendido: 0,
          "No compete": 0
        };

        estados.forEach(estado => {
          if (filtroEstado && filtroEstado !== 'Todos' && estado !== filtroEstado) {
            return;
          }
          const mesKey = normalizeMesKey(filtroMes);
          let count = 0;
          if (entry) {
            if (mesKey) {
              count = entry.mes_tipo_estado[`${mesKey}|${tipo}|${estado}`] || 0;
            } else if (filtroTipo && filtroEstado && filtroTipo !== 'Todos' && filtroEstado !== 'Todos') {
              count = entry.tipo_estado[`${tipo}|${estado}`] || 0;
            } else {
              count = entry.tipo_estado[`${tipo}|${estado}`] || 0;
            }
          }

          tiposPorEstado[tipo][estado] = (tiposPorEstado[tipo][estado] || 0) + count;
          tiposPorEstado[tipo].total += count;
        });
      });
    } else {
      // ‚úÖ OPTIMIZACI√ìN CR√çTICA: Usar obtenerIdsFiltrados() en lugar de iterar todo solicitudes
      const idsFiltrados = obtenerIdsFiltrados(filtroTipo, filtroEstado, filtroMes, true);
      
      const seccionKey = normalizeSeccionKey(seccion);
      
      idsFiltrados.forEach(id => {
        const s = solicitudPorId[id];
        if (!s) return;
        
        const solicitudSeccion = s.seccion || s.SECCION;
        if (!solicitudSeccion) return;
        const solicitudKey = normalizeSeccionKey(solicitudSeccion);
        
        if (solicitudKey && seccionKey && solicitudKey === seccionKey && s["Tipo de reporte"] && s["Estado Reporte"]) {
          const tipo = s["Tipo de reporte"];
          const estado = s["Estado Reporte"];
          
          if (!tiposPorEstado[tipo]) {
            tiposPorEstado[tipo] = {
              total: 0,
              Pendiente: 0,
              "En atenci√≥n": 0,
              Atendido: 0,
              "No compete": 0
            };
          }
          
          tiposPorEstado[tipo].total++;
          tiposPorEstado[tipo][estado] = (tiposPorEstado[tipo][estado] || 0) + 1;
        }
      });
    }
    
    const top5 = Object.entries(tiposPorEstado)
      .sort((a, b) => b[1].total - a[1].total)
      .slice(0, 5);
    
    cacheTop5Secciones[cacheKey] = top5;
    
    return top5;
  }

  // ========== GENERAR TABLA DIN√ÅMICA ==========
  function generarTablaDinamica(sortColumn = null, sortDirection = null) {
    const fila1 = document.getElementById('dinamicaFilas').value;
    const fila2 = document.getElementById('dinamicaFilas2').value;
    const columnas = document.getElementById('dinamicaColumnas').value;
    const valores = document.getElementById('dinamicaValores').value;
    const mostrarTotales = document.getElementById('dinamicaMostrarTotales').checked;
    const ordenar = document.getElementById('dinamicaOrdenar').checked;
    
    // Si es la primera generaci√≥n, procesar datos
    if (sortColumn === null) {
      // ‚ö†Ô∏è TABLA FIJA: Siempre usar TODOS los datos sin aplicar filtros
      // Para que la tabla Top 10 Solicitudes Pendientes no cambie con los filtros
      const idsFiltrados = allIds; // Usar todos los IDs en lugar de filtrados
      
      if (!solicitudPorId || idsFiltrados.length === 0) {
        document.getElementById('contenidoTablaDinamica').innerHTML = '<p style="text-align:center; color:#666; padding:40px;">No hay datos disponibles</p>';
        return;
      }
      
      // Funci√≥n para extraer valor de un campo (incluye l√≥gica especial para mes)
      const extraerValor = (solicitud, campo) => {
        if (campo === 'mes') {
          const fechaStr = solicitud["Fecha reporte"];
          if (!fechaStr) return 'Sin fecha';
          const fecha = new Date(fechaStr);
          if (isNaN(fecha)) return 'Sin fecha';
          let mes = fecha.toLocaleString('es-ES', { month: 'long', year: 'numeric' });
          return mes.charAt(0).toUpperCase() + mes.slice(1);
        }
        if (campo === 'name') {
          return solicitud["Colonia"] || 'Sin colonia';
        }
        return solicitud[campo] || 'Sin datos';
      };
      
      // Crear estructura de datos usando los mismos IDs que tablas/gr√°ficas
      const datos = {};
      const columnasSet = new Set();
      let totalGeneral = 0;
      
      idsFiltrados.forEach(id => {
        const s = solicitudPorId[id];
        if (!s) return;
        
        // Obtener valores de fila (con subgrupo si aplica)
        const valorFila1 = extraerValor(s, fila1);
        let claveFilaFinal = valorFila1;
        
        if (fila2 !== 'ninguna') {
          const valorFila2 = extraerValor(s, fila2);
          claveFilaFinal = `${valorFila1} ‚Üí ${valorFila2}`;
        }
        
        // Obtener valor de columna
        let valorColumna = 'Total';
        if (columnas !== 'ninguna') {
          valorColumna = extraerValor(s, columnas);
        }
        
        columnasSet.add(valorColumna);
        
        if (!datos[claveFilaFinal]) datos[claveFilaFinal] = {};
        if (!datos[claveFilaFinal][valorColumna]) datos[claveFilaFinal][valorColumna] = 0;
        
        datos[claveFilaFinal][valorColumna]++;
        totalGeneral++;
      });
      
      // Guardar datos y configuraci√≥n para ordenamiento
      tablaDinamicaDatos = {
        datos: datos,
        columnasSet: columnasSet,
        totalGeneral: totalGeneral,
        idsFiltrados: idsFiltrados,
        filtroTipo: filtroTipo,
        filtroEstado: filtroEstado,
        filtroMes: filtroMes
      };
      
      tablaDinamicaConfig = {
        fila1: fila1,
        fila2: fila2,
        columnas: columnas,
        valores: valores,
        mostrarTotales: mostrarTotales,
        ordenar: ordenar
      };
    }
    
    // Usar datos guardados
    const datos = tablaDinamicaDatos.datos;
    const columnasSet = tablaDinamicaDatos.columnasSet;
    const totalGeneral = tablaDinamicaDatos.totalGeneral;
    const featuresFiltradas = tablaDinamicaDatos.featuresFiltradas;
    
    // Calcular totales por fila
    const totalesPorFila = {};
    for (let fila in datos) {
      totalesPorFila[fila] = 0;
      for (let col in datos[fila]) {
        totalesPorFila[fila] += datos[fila][col];
      }
    }
    
    // Ordenar filas
    let filasOrdenadas = Object.keys(datos);
    
    // Si se especifica columna de ordenamiento, ordenar por esa columna
    if (sortColumn !== null) {
      tablaDinamicaSortCol = sortColumn;
      tablaDinamicaSortDir = sortDirection || (tablaDinamicaSortCol === sortColumn && tablaDinamicaSortDir === 'desc' ? 'asc' : 'desc');
      
      if (sortColumn === '__fila__') {
        // Ordenar por nombre de fila (detectar si son n√∫meros, meses o texto)
        filasOrdenadas.sort((a, b) => {
          // Verificar si son n√∫meros
          const numA = parseFloat(a.replace(/,/g, ''));
          const numB = parseFloat(b.replace(/,/g, ''));
          if (!isNaN(numA) && !isNaN(numB)) {
            return tablaDinamicaSortDir === 'asc' ? numA - numB : numB - numA;
          }
          
          // Verificar si son meses
          const mesesOrden = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 
                              'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'];
          const mesA = mesesOrden.findIndex(m => a.toLowerCase().includes(m));
          const mesB = mesesOrden.findIndex(m => b.toLowerCase().includes(m));
          if (mesA !== -1 && mesB !== -1) {
            return tablaDinamicaSortDir === 'asc' ? mesA - mesB : mesB - mesA;
          }
          
          // Ordenamiento alfab√©tico
          if (tablaDinamicaSortDir === 'asc') {
            return a.localeCompare(b, 'es', {sensitivity: 'base'});
          } else {
            return b.localeCompare(a, 'es', {sensitivity: 'base'});
          }
        });
      } else if (sortColumn === '__total__') {
        // Ordenar por total (siempre num√©rico)
        filasOrdenadas.sort((a, b) => {
          if (tablaDinamicaSortDir === 'asc') {
            return totalesPorFila[a] - totalesPorFila[b];
          } else {
            return totalesPorFila[b] - totalesPorFila[a];
          }
        });
      } else {
        // Ordenar por columna espec√≠fica (num√©rico)
        filasOrdenadas.sort((a, b) => {
          const valA = datos[a][sortColumn] || 0;
          const valB = datos[b][sortColumn] || 0;
          if (tablaDinamicaSortDir === 'asc') {
            return valA - valB;
          } else {
            return valB - valA;
          }
        });
      }
    } else if (ordenar) {
      // Ordenamiento inicial por total
      filasOrdenadas.sort((a, b) => totalesPorFila[b] - totalesPorFila[a]);
      tablaDinamicaSortCol = '__total__';
      tablaDinamicaSortDir = 'desc';
    } else {
      filasOrdenadas.sort();
      tablaDinamicaSortCol = '__fila__';
      tablaDinamicaSortDir = 'asc';
    }
    
    // Ordenar columnas
    let columnasOrdenadas = Array.from(columnasSet);
    if (columnas === 'mes') {
      // Ordenar meses cronol√≥gicamente
      const mesesOrden = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 
                          'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'];
      columnasOrdenadas.sort((a, b) => {
        const mesA = mesesOrden.findIndex(m => a.toLowerCase().includes(m));
        const mesB = mesesOrden.findIndex(m => b.toLowerCase().includes(m));
        return mesA - mesB;
      });
    } else {
      columnasOrdenadas.sort();
    }
    
    // Si hay columnas, mover 'Total' al final
    if (columnas !== 'ninguna' && columnasOrdenadas.includes('Total')) {
      columnasOrdenadas = columnasOrdenadas.filter(c => c !== 'Total');
      columnasOrdenadas.push('Total');
    }
    
    // Generar tabla HTML
    const nombreFila1 = fila1 === 'Tipo de reporte' ? 'Tipo de Reporte' : 
                        fila1 === 'Estado Reporte' ? 'Estado' : 
                        fila1 === 'name' ? 'Colonia' : 
                        fila1 === 'mes' ? 'Mes' : 
                        fila1 === 'Nombre Ciudadano' ? 'Ciudadano' :
                        fila1 === 'Punto de referencia' ? 'Punto Referencia' : fila1;
    
    const nombreFila2 = fila2 !== 'ninguna' ? (' + ' + (fila2 === 'Tipo de reporte' ? 'Tipo' : 
                        fila2 === 'Estado Reporte' ? 'Estado' : 
                        fila2 === 'name' ? 'Colonia' : 
                        fila2 === 'mes' ? 'Mes' : 
                        fila2 === 'Nombre Ciudadano' ? 'Ciudadano' : fila2)) : '';
    
    let tabla = `<table class="table table-bordered" style="font-size: 11px; border-collapse: collapse;">
      <thead><tr style="border: 2px solid #dee2e6;">
        <th class="sortable-header ${tablaDinamicaSortCol === '__fila__' ? 'sort-' + tablaDinamicaSortDir : ''}" data-col="__fila__" style="position:sticky; left:0; background-color:#f8f9fa; z-index:10; cursor:pointer; border: 1px solid #dee2e6; padding:8px; font-weight:bold;">${nombreFila1}${nombreFila2}</th>`;
    
    columnasOrdenadas.forEach(col => {
      const sortClass = tablaDinamicaSortCol === col ? 'sort-' + tablaDinamicaSortDir : '';
      tabla += `<th class="sortable-header ${sortClass}" data-col="${col}" style="text-align:center; cursor:pointer; border: 1px solid #dee2e6; padding:8px; background-color:#f8f9fa; font-weight:bold;">${col}</th>`;
    });
    
    if (mostrarTotales && columnas !== 'ninguna') {
      const sortClass = tablaDinamicaSortCol === '__total__' ? 'sort-' + tablaDinamicaSortDir : '';
      tabla += `<th class="sortable-header ${sortClass}" data-col="__total__" style="text-align:center; font-weight:bold; cursor:pointer; border: 1px solid #dee2e6; padding:8px; background-color:#f8f9fa;">TOTAL</th>`;
    }
    
    tabla += `</tr></thead><tbody>`;
    
    // Calcular totales por columna
    const totalesPorColumna = {};
    columnasOrdenadas.forEach(col => {
      totalesPorColumna[col] = 0;
      filasOrdenadas.forEach(fila => {
        totalesPorColumna[col] += (datos[fila][col] || 0);
      });
    });
    
    // Filas de datos (con soporte para subgrupos)
    if (fila2 !== 'ninguna') {
      // Primero, ordenar filasOrdenadas para asegurar que los grupos principales est√©n juntos
      // Extraer solo las principales para ordenar
      const principalesSet = new Set();
      filasOrdenadas.forEach(fila => {
        const partes = fila.split(' ‚Üí ');
        principalesSet.add(partes[0]);
      });
      
      const principalesOrdenadas = Array.from(principalesSet);
      
      // Ordenar principales seg√∫n el criterio actual
      if (sortColumn === '__fila__') {
        // Ordenar por nombre de principal
        principalesOrdenadas.sort((a, b) => {
          const numA = parseFloat(a.replace(/,/g, ''));
          const numB = parseFloat(b.replace(/,/g, ''));
          if (!isNaN(numA) && !isNaN(numB)) {
            return tablaDinamicaSortDir === 'asc' ? numA - numB : numB - numA;
          }
          const mesesOrden = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 
                              'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'];
          const mesA = mesesOrden.findIndex(m => a.toLowerCase().includes(m));
          const mesB = mesesOrden.findIndex(m => b.toLowerCase().includes(m));
          if (mesA !== -1 && mesB !== -1) {
            return tablaDinamicaSortDir === 'asc' ? mesA - mesB : mesB - mesA;
          }
          if (tablaDinamicaSortDir === 'asc') {
            return a.localeCompare(b, 'es', {sensitivity: 'base'});
          } else {
            return b.localeCompare(a, 'es', {sensitivity: 'base'});
          }
        });
      } else {
        // Ordenar por suma de totales de cada principal
        const totalesPrincipales = {};
        principalesOrdenadas.forEach(principal => {
          totalesPrincipales[principal] = 0;
          filasOrdenadas.forEach(fila => {
            if (fila.startsWith(principal + ' ‚Üí ')) {
              totalesPrincipales[principal] += totalesPorFila[fila] || 0;
            }
          });
        });
        
        principalesOrdenadas.sort((a, b) => {
          if (sortColumn === '__total__') {
            return tablaDinamicaSortDir === 'desc' 
              ? totalesPrincipales[b] - totalesPrincipales[a]
              : totalesPrincipales[a] - totalesPrincipales[b];
          } else {
            // Ordenar por columna espec√≠fica - sumar valores de subgrupos
            let sumA = 0, sumB = 0;
            filasOrdenadas.forEach(fila => {
              if (fila.startsWith(a + ' ‚Üí ')) sumA += datos[fila][sortColumn] || 0;
              if (fila.startsWith(b + ' ‚Üí ')) sumB += datos[fila][sortColumn] || 0;
            });
            return tablaDinamicaSortDir === 'desc' ? sumB - sumA : sumA - sumB;
          }
        });
      }
      
      // Agrupar por fila principal para crear filas desplegables
      const gruposPrincipales = {};
      principalesOrdenadas.forEach(principal => {
        gruposPrincipales[principal] = { subgrupos: [], totales: {} };
        
        filasOrdenadas.forEach(fila => {
          const partes = fila.split(' ‚Üí ');
          if (partes[0] === principal) {
            const secundaria = partes[1] || '';
            gruposPrincipales[principal].subgrupos.push({ nombre: secundaria, claveFila: fila });
            
            // Acumular totales del grupo principal
            columnasOrdenadas.forEach(col => {
              const val = datos[fila][col] || 0;
              gruposPrincipales[principal].totales[col] = (gruposPrincipales[principal].totales[col] || 0) + val;
            });
          }
        });
      });
      
      // Generar filas con toggle (usando el orden ya calculado)
      principalesOrdenadas.forEach(principal => {
        const grupo = gruposPrincipales[principal];
        const totalGrupo = Object.values(grupo.totales).reduce((a, b) => a + b, 0);
        
        // Fila principal (clickeable)
        tabla += `<tr class="toggle-row" data-group="${principal.replace(/"/g, '&quot;')}" style="cursor:pointer; background-color:#f8f9fa; font-weight:600; border: 1px solid #dee2e6;">
          <td style="position:sticky; left:0; background-color:#f8f9fa; border: 1px solid #dee2e6; padding:8px;">
            <span class="toggle-icon" style="display:inline-block; width:20px; font-weight:bold;">‚ñ∂</span>
            ${principal}
          </td>`;
        
        columnasOrdenadas.forEach(col => {
          const valor = grupo.totales[col] || 0;
          let contenido = valor > 0 ? valor.toLocaleString('es-MX') : '-';
          tabla += `<td style="text-align:center; border: 1px solid #dee2e6; padding:8px;">${contenido}</td>`;
        });
        
        if (mostrarTotales && columnas !== 'ninguna') {
          tabla += `<td style="text-align:center; font-weight:bold; background-color:#f8f9fa; border: 1px solid #dee2e6; padding:8px;">${totalGrupo.toLocaleString('es-MX')}</td>`;
        }
        
        tabla += `</tr>`;
        
        // Filas secundarias (ocultas inicialmente)
        grupo.subgrupos.forEach(sub => {
          const fila = sub.claveFila;
          tabla += `<tr class="detail-row" data-parent="${principal.replace(/"/g, '&quot;')}" style="display:none; border: 1px solid #dee2e6;">
            <td style="position:sticky; left:0; background-color:white; padding-left:35px; border: 1px solid #dee2e6; padding:8px;">${sub.nombre}</td>`;
          
          columnasOrdenadas.forEach(col => {
            const valor = datos[fila][col] || 0;
            let contenido = '';
            
            if (valores === 'porcentaje' && totalesPorFila[fila] > 0) {
              const pct = (valor / totalesPorFila[fila] * 100).toFixed(1);
              contenido = valor > 0 ? `${valor.toLocaleString('es-MX')} (${pct}%)` : '-';
            } else {
              contenido = valor > 0 ? valor.toLocaleString('es-MX') : '-';
            }
            
            tabla += `<td style="text-align:center; border: 1px solid #dee2e6; padding:8px;">${contenido}</td>`;
          });
          
          if (mostrarTotales && columnas !== 'ninguna') {
            tabla += `<td style="text-align:center; font-weight:bold; background-color:#f8f9fa; border: 1px solid #dee2e6; padding:8px;">${totalesPorFila[fila].toLocaleString('es-MX')}</td>`;
          }
          
          tabla += `</tr>`;
        });
      });
    } else {
      // Sin subgrupos, generar filas normales
      filasOrdenadas.forEach(fila => {
        tabla += `<tr style="border: 1px solid #dee2e6;"><td style="position:sticky; left:0; background-color:white; font-weight:600; border: 1px solid #dee2e6; padding:8px;">${fila}</td>`;
        
        columnasOrdenadas.forEach(col => {
          const valor = datos[fila][col] || 0;
          let contenido = '';
          
          if (valores === 'porcentaje' && totalesPorFila[fila] > 0) {
            const pct = (valor / totalesPorFila[fila] * 100).toFixed(1);
            contenido = valor > 0 ? `${valor.toLocaleString('es-MX')} (${pct}%)` : '-';
          } else {
            contenido = valor > 0 ? valor.toLocaleString('es-MX') : '-';
          }
          
          tabla += `<td style="text-align:center; border: 1px solid #dee2e6; padding:8px;">${contenido}</td>`;
        });
        
        if (mostrarTotales && columnas !== 'ninguna') {
          tabla += `<td style="text-align:center; font-weight:bold; background-color:#f8f9fa; border: 1px solid #dee2e6; padding:8px;">${totalesPorFila[fila].toLocaleString('es-MX')}</td>`;
        }
        
        tabla += `</tr>`;
      });
    }
    
    // Fila de totales
    if (mostrarTotales) {
      tabla += `<tr style="border: 2px solid #dee2e6; font-weight:bold;">
        <td style="position:sticky; left:0; background-color:#f8f9fa; border: 1px solid #dee2e6; padding:8px;">TOTAL</td>`;
      
      columnasOrdenadas.forEach(col => {
        tabla += `<td style="text-align:center; border: 1px solid #dee2e6; padding:8px;">${totalesPorColumna[col].toLocaleString('es-MX')}</td>`;
      });
      
      if (columnas !== 'ninguna') {
        tabla += `<td style="text-align:center; border: 1px solid #dee2e6; padding:8px;">${totalGeneral.toLocaleString('es-MX')}</td>`;
      }
      
      tabla += `</tr>`;
    }
    
    tabla += `</tbody></table>`;
    
    // Agregar informaci√≥n de filtros aplicados
    let infoFiltros = '<div style="padding: 10px; background: #fff3cd; border-radius: 4px; margin-bottom: 10px; font-size: 12px;">';
    infoFiltros += `<strong>Datos filtrados:</strong> ${tablaDinamicaDatos.idsFiltrados.length.toLocaleString('es-MX')} solicitudes de ${allIds.length.toLocaleString('es-MX')} totales`;
    if (tablaDinamicaDatos.filtroTipo !== 'Todos') infoFiltros += ` | Tipo: ${tablaDinamicaDatos.filtroTipo}`;
    if (tablaDinamicaDatos.filtroEstado !== 'Todos') infoFiltros += ` | Estado: ${tablaDinamicaDatos.filtroEstado}`;
    if (tablaDinamicaDatos.filtroMes !== 'Todos') infoFiltros += ` | Mes: ${tablaDinamicaDatos.filtroMes}`;
    infoFiltros += '<br><em style="color:#666;">Haz clic en los encabezados para ordenar. Selecciona celdas para ver estad√≠sticas.</em>';
    infoFiltros += '</div>';
    
    // Mostrar tabla
    document.getElementById('contenidoTablaDinamica').innerHTML = infoFiltros + tabla;
    
    // Agregar event listeners a los encabezados para ordenar
    setTimeout(() => {
      const headers = document.querySelectorAll('#contenidoTablaDinamica .sortable-header');
      headers.forEach(header => {
        header.addEventListener('click', function() {
          const col = this.getAttribute('data-col');
          generarTablaDinamica(col);
        });
      });
      
      // Event listeners para filas desplegables
      const toggleRows = document.querySelectorAll('#contenidoTablaDinamica .toggle-row');
      toggleRows.forEach(row => {
        row.addEventListener('click', function() {
          const group = this.getAttribute('data-group');
          const icon = this.querySelector('.toggle-icon');
          const detailRows = document.querySelectorAll(`#contenidoTablaDinamica .detail-row[data-parent="${group}"]`);
          
          detailRows.forEach(detailRow => {
            if (detailRow.style.display === 'none') {
              detailRow.style.display = 'table-row';
              icon.textContent = '‚ñº';
            } else {
              detailRow.style.display = 'none';
              icon.textContent = '‚ñ∂';
            }
          });
        });
      });
      
      // Habilitar selecci√≥n de celdas para estad√≠sticas
      const tableElement = document.querySelector('#contenidoTablaDinamica table');
      if (tableElement) {
        habilitarSeleccionEnTabla(tableElement);
      }
    }, 50);
  }

  // ========== GENERAR TABLA GENERAL ==========
  // Tabla completa con TODOS los tipos de solicitud por mes
  function generarTablaGeneral(filtroTipo, filtroEstado, filtroMes) {
    if (statsData && statsLoaded) {
      const mesesBase = (statsData.values && statsData.values.mes) ? statsData.values.mes : [];
      const mesFiltro = normalizeMesKey(filtroMes);
      const mesesOrdenados = mesesBase.filter(m => !mesFiltro || m === mesFiltro);

      const tiposBase = (statsData.values && statsData.values.tipo) ? statsData.values.tipo : [];
      const tiposOrdenados = tiposBase
        .map(tipo => ({ tipo, total: getStatsCount(statsData.global, tipo, filtroEstado, mesFiltro) }))
        .sort((a, b) => b.total - a.total)
        .map(e => e.tipo);

      let tabla = `<table class="table table-bordered" style="font-size:11px; border-collapse: collapse;">
        <thead><tr style="border: 2px solid #dee2e6;">
          <th style="position:sticky; left:0; background-color:#f8f9fa; z-index:10; padding:8px; border: 1px solid #dee2e6; font-weight:bold;">Tipo de Solicitud</th>`;

      mesesOrdenados.forEach(m => {
        const nombreMes = m.charAt(0).toUpperCase() + m.slice(1);
        tabla += `<th style="text-align:center; padding:8px; border: 1px solid #dee2e6; background-color:#f8f9fa; font-weight:bold;">${nombreMes}</th>`;
      });
      tabla += `<th style="text-align:center; font-weight:bold; padding:8px; border: 1px solid #dee2e6; background-color:#f8f9fa;">Total</th>`;
      tabla += `</tr></thead><tbody>`;

      const totalesPorMes = {};
      mesesOrdenados.forEach(m => { totalesPorMes[m] = 0; });

      tiposOrdenados.forEach(tipo => {
        tabla += `<tr style="border: 1px solid #dee2e6;"><td style="position:sticky; left:0; background-color:white; font-weight:600; border: 1px solid #dee2e6; padding:8px;">${tipo}</td>`;
        let totalFila = 0;
        mesesOrdenados.forEach(m => {
          const valor = getStatsCount(statsData.global, tipo, filtroEstado, m);
          totalFila += valor;
          totalesPorMes[m] += valor;
          tabla += `<td style="text-align:center; border: 1px solid #dee2e6; padding:8px;">${valor > 0 ? valor.toLocaleString('es-MX') : '-'}</td>`;
        });
        tabla += `<td style="text-align:center; font-weight:bold; background-color:#f8f9fa; border: 1px solid #dee2e6; padding:8px;">${totalFila.toLocaleString('es-MX')}</td>`;
        tabla += `</tr>`;
      });

      tabla += `<tr style="border: 2px solid #dee2e6; font-weight:bold;">
        <td style="position:sticky; left:0; background-color:#f8f9fa; padding:8px; border: 1px solid #dee2e6;">TOTAL</td>`;
      let granTotal = 0;
      mesesOrdenados.forEach(m => {
        const total = totalesPorMes[m] || 0;
        granTotal += total;
        tabla += `<td style="text-align:center; padding:8px; border: 1px solid #dee2e6;">${total.toLocaleString('es-MX')}</td>`;
      });
      tabla += `<td style="text-align:center; padding:8px; border: 1px solid #dee2e6;">${granTotal.toLocaleString('es-MX')}</td>`;
      tabla += `</tr></tbody></table>`;

      document.getElementById('contenidoTablaGeneral').innerHTML = tabla;
      setTimeout(() => {
        const tableElement = document.querySelector('#contenidoTablaGeneral table');
        if (tableElement) {
          habilitarSeleccionEnTabla(tableElement);
        }
      }, 50);
      return;
    }

    // Usar los MISMOS datos filtrados que usa la gr√°fica
    const idsFiltradosIgnoreCol = obtenerIdsFiltrados(filtroTipo, filtroEstado, filtroMes, true);
    
    // Agrupar por tipo y mes
    let resumenPorTipo = {};
    let totalesPorTipo = {};
    
    idsFiltradosIgnoreCol.forEach(id => {
      const s = solicitudPorId[id];
      if(!s || !s["Fecha reporte"] || !s["Tipo de reporte"]) return;
      
      let fecha = new Date(s["Fecha reporte"]);
      if(isNaN(fecha)) return;

      let mesClave = fecha.getFullYear()+"-"+(fecha.getMonth()+1).toString().padStart(2,"0");
      let tipo = s["Tipo de reporte"];
      
      if(!resumenPorTipo[tipo]) {
        resumenPorTipo[tipo] = {};
      }
      if(!resumenPorTipo[tipo][mesClave]) {
        resumenPorTipo[tipo][mesClave] = 0;
      }
      resumenPorTipo[tipo][mesClave]++;
      
      if(!totalesPorTipo[tipo]) {
        totalesPorTipo[tipo] = 0;
      }
      totalesPorTipo[tipo]++;
    });

    // Ordenar tipos por total (descendente)
    let tiposOrdenados = Object.entries(totalesPorTipo)
      .sort((a, b) => b[1] - a[1])
      .map(e => e[0]);

    // Obtener todos los meses
    let todosLosMeses = new Set();
    for(let tipo in resumenPorTipo) {
      for(let mesClave in resumenPorTipo[tipo]) {
        todosLosMeses.add(mesClave);
      }
    }
    
    let mesesOrdenados = Array.from(todosLosMeses).sort();
    
    const mesesEspecificos = mesesOrdenados.map(mesClave => {
      const [anio, mesNum] = mesClave.split("-");
      const fecha = new Date(anio, parseInt(mesNum)-1);
      let nombreMes = fecha.toLocaleString('es-ES',{month:'long'});
      nombreMes = nombreMes.charAt(0).toUpperCase() + nombreMes.slice(1);
      return { clave: mesClave, nombre: nombreMes };
    });

    // Renderizar tabla
    let tabla = `<table class="table table-bordered" style="font-size:11px; border-collapse: collapse;">
      <thead><tr style="border: 2px solid #dee2e6;">
        <th style="position:sticky; left:0; background-color:#f8f9fa; z-index:10; padding:8px; border: 1px solid #dee2e6; font-weight:bold;">Tipo de Solicitud</th>`;
    
    mesesEspecificos.forEach(m => {
      tabla += `<th style="text-align:center; padding:8px; border: 1px solid #dee2e6; background-color:#f8f9fa; font-weight:bold;">${m.nombre}</th>`;
    });
    tabla += `<th style="text-align:center; font-weight:bold; padding:8px; border: 1px solid #dee2e6; background-color:#f8f9fa;">Total</th>`;
    tabla += `</tr></thead><tbody>`;

    // Totales por mes
    let totalesPorMes = {};
    mesesEspecificos.forEach(m => { totalesPorMes[m.clave] = 0; });

    // Filas de tipos
    tiposOrdenados.forEach(tipo => {
      tabla += `<tr style="border: 1px solid #dee2e6;"><td style="position:sticky; left:0; background-color:white; font-weight:600; border: 1px solid #dee2e6; padding:8px;">${tipo}</td>`;
      
      mesesEspecificos.forEach(m => {
        let valor = resumenPorTipo[tipo] && resumenPorTipo[tipo][m.clave] 
          ? resumenPorTipo[tipo][m.clave] 
          : 0;
        totalesPorMes[m.clave] += valor;
        tabla += `<td style="text-align:center; border: 1px solid #dee2e6; padding:8px;">${valor > 0 ? valor.toLocaleString('es-MX') : '-'}</td>`;
      });
      
      tabla += `<td style="text-align:center; font-weight:bold; background-color:#f8f9fa; border: 1px solid #dee2e6; padding:8px;">${totalesPorTipo[tipo].toLocaleString('es-MX')}</td>`;
      tabla += `</tr>`;
    });

    // Fila de totales
    tabla += `<tr style="border: 2px solid #dee2e6; font-weight:bold;">
      <td style="position:sticky; left:0; background-color:#f8f9fa; padding:8px; border: 1px solid #dee2e6;">TOTAL</td>`;
    
    let granTotal = 0;
    mesesEspecificos.forEach(m => {
      let total = totalesPorMes[m.clave];
      granTotal += total;
      tabla += `<td style="text-align:center; padding:8px; border: 1px solid #dee2e6;">${total.toLocaleString('es-MX')}</td>`;
    });
    tabla += `<td style="text-align:center; padding:8px; border: 1px solid #dee2e6;">${granTotal.toLocaleString('es-MX')}</td>`;
    tabla += `</tr></tbody></table>`;

    // Mostrar en el contenedor de la pesta√±a
    document.getElementById('contenidoTablaGeneral').innerHTML = tabla;
    
    // Habilitar selecci√≥n de celdas para estad√≠sticas
    setTimeout(() => {
      const tableElement = document.querySelector('#contenidoTablaGeneral table');
      if (tableElement) {
        habilitarSeleccionEnTabla(tableElement);
      }
    }, 50);
  }

  // ========== GENERAR TABLA TOP 10 ==========
  // Tabla Top 10 por tipo de solicitud - COMPLETAMENTE EST√ÅTICA, siempre muestra los mismos datos
  function generarTablaTop10(filtroTipo, filtroEstado, filtroMes) {
    // ‚úÖ Si la tabla ya fue generada, simplemente mostrar el cache (tabla completamente est√°tica)
    if (tablaCacheTop10 !== null) {
      document.getElementById("tablaTop10").innerHTML = tablaCacheTop10;
      setTimeout(() => {
        const tabla = document.querySelector('#tablaTop10 table');
        if (tabla) habilitarSeleccionEnTabla(tabla);
      }, 50);
      return;
    }
    
    // ‚úÖ GENERAR TABLA SIN APLICAR NING√öN FILTRO - Solo usar allIds
    // No usar statsData, no aplicar filtros de tipo/estado/mes
    const idsFiltrados = allIds;  // TODOS los datos sin filtros
    
    if (!idsFiltrados || idsFiltrados.length === 0) {
      tablaCacheTop10 = '<p>No hay datos disponibles</p>';
      document.getElementById("tablaTop10").innerHTML = tablaCacheTop10;
      return;
    }

    // Agrupar por tipo y mes usando TODOS los IDs sin filtros
    let resumenPorTipo = {};
    let totalesPorTipo = {};
    
    // Iterar sobre TODOS los IDs sin aplicar filtros
    idsFiltrados.forEach(id => {
      const s = solicitudPorId[id];
      if (!s) return;
      
      const tipo = s["Tipo de reporte"];
      const estado = s["Estado Reporte"];
      
      if (!tipo || !estado) return;
      
      const estadoTrim = estado.trim();
      
      // Para agrupar por mes
      let mesClave;
      if (s["Fecha reporte"]) {
        const fecha = new Date(s["Fecha reporte"]);
        if (!isNaN(fecha)) {
          mesClave = fecha.getFullYear()+"-"+(fecha.getMonth()+1).toString().padStart(2,"0");
        } else {
          mesClave = "Sin fecha";
        }
      } else {
        mesClave = "Sin fecha";
      }
      
      if (!resumenPorTipo[tipo]) {
        resumenPorTipo[tipo] = {};
      }
      if (!resumenPorTipo[tipo][mesClave]) {
        resumenPorTipo[tipo][mesClave] = {
          Pendiente: 0,
          "En atenci√≥n": 0,
          total: 0
        };
      }
      
      // Contar SOLO los que tienen estado "Pendiente" para el ranking
      if (estadoTrim === "Pendiente") {
        resumenPorTipo[tipo][mesClave].Pendiente++;
        if (!totalesPorTipo[tipo]) {
          totalesPorTipo[tipo] = 0;
        }
        totalesPorTipo[tipo]++;
      } else if (estadoTrim === "En atenci√≥n") {
        resumenPorTipo[tipo][mesClave]["En atenci√≥n"]++;
      }
    });

    // Ordenar por TOTAL de solicitudes Pendientes
    let tiposConTotal = [];
    for(let tipo in totalesPorTipo) {
      tiposConTotal.push({ tipo: tipo, total: totalesPorTipo[tipo] });
    }

    // Ordenar y tomar top 10
    tiposConTotal.sort((a, b) => b.total - a.total);
    let top10 = tiposConTotal.slice(0, 10);

    // Obtener TODOS los meses que existen en los datos
    let todosLosMeses = new Set();
    for(let tipo in resumenPorTipo) {
      for(let mesClave in resumenPorTipo[tipo]) {
        todosLosMeses.add(mesClave);
      }
    }
    
    // Convertir a array y ordenar cronol√≥gicamente
    let mesesOrdenados = Array.from(todosLosMeses).sort();
    
    // Crear array de objetos con nombre
    const mesesEspecificos = mesesOrdenados.map(mesClave => {
      const [anio, mesNum] = mesClave.split("-");
      const fecha = new Date(anio, parseInt(mesNum)-1);
      let nombreMes = fecha.toLocaleString('es-ES',{month:'long'});
      nombreMes = nombreMes.charAt(0).toUpperCase() + nombreMes.slice(1);
      return { clave: mesClave, nombre: nombreMes };
    });

    // Calcular indicador de d√≠as por columna (mes)
    let indicadoresPorMes = {};
    let totalMeses = mesesEspecificos.length;
    mesesEspecificos.forEach((mesObj, idx) => {
      let distanciaDesdeFinal = (totalMeses - 1) - idx;
      let factor = distanciaDesdeFinal * 30;
      if (distanciaDesdeFinal === 0) factor = 1;
      
      let sumaPendientes = 0;
      top10.forEach(t => {
        let valorMes = resumenPorTipo[t.tipo] && resumenPorTipo[t.tipo][mesObj.clave] 
          ? resumenPorTipo[t.tipo][mesObj.clave].Pendiente 
          : 0;
        sumaPendientes += valorMes;
      });
      
      indicadoresPorMes[mesObj.clave] = sumaPendientes * factor;
    });

    // Renderizar tabla
    let tabla = `<table class="table table-striped">
      <thead><tr>
        <th>Tipo de Solicitud</th>`;
    
    mesesEspecificos.forEach(m => {
      tabla += `<th>${m.nombre}</th>`;
    });
    tabla += `<th>Total</th>`;
    tabla += `</tr></thead><tbody>`;

    // Calcular total del indicador para la columna Total
    let totalIndicadorGlobal = 0;
    mesesEspecificos.forEach(m => {
      totalIndicadorGlobal += indicadoresPorMes[m.clave];
    });

    // Filas de tipos (Top 10)
    let sumaTotalesColumna = 0;
    top10.forEach(t => {
      tabla += `<tr><td><strong>${t.tipo}</strong></td>`;
      let totalFila = 0;
      mesesEspecificos.forEach(m => {
        let valor = resumenPorTipo[t.tipo] && resumenPorTipo[t.tipo][m.clave] 
          ? resumenPorTipo[t.tipo][m.clave].Pendiente 
          : 0;
        totalFila += valor;
        tabla += `<td>${valor.toLocaleString('es-MX')}</td>`;
      });
      sumaTotalesColumna += totalFila;
      tabla += `<td style="font-weight:bold;">${totalFila.toLocaleString('es-MX')}</td>`;
      tabla += `</tr>`;
    });

    // Fila de indicador de d√≠as
    tabla += `<tr style="font-weight:bold;">
      <td>Indicador de d√≠as por solicitudes</td>`;
    mesesEspecificos.forEach(m => {
      tabla += `<td>${indicadoresPorMes[m.clave].toLocaleString('es-MX')}</td>`;
    });
    tabla += `<td>${sumaTotalesColumna.toLocaleString('es-MX')}</td>`;
    tabla += `</tr>`;

    tabla += `</tbody></table>`;
    
    // ‚úÖ GUARDAR EN CACHE: La tabla es completamente est√°tica y no cambia con filtros
    tablaCacheTop10 = tabla;
    
    document.getElementById("tablaTop10").innerHTML = tabla;
    
    // Habilitar selecci√≥n de celdas con estad√≠sticas
    setTimeout(() => {
      const tablaEl = document.querySelector('#tablaTop10 table');
      if (tablaEl) habilitarSeleccionEnTabla(tablaEl);
    }, 50);
  }

  // ========== GENERAR TABLA RESUMEN ==========
  // Tabla resumen (con Pendientes/En Atenci√≥n + Indicador din√°mico + Totales en negritas)
  // Solo se afecta por filtro de Tipo, ignora Estado y Mes
  function generarTablaResumen(filtroTipo){
    if (statsData && statsLoaded) {
      const mesesBase = (statsData.values && statsData.values.mes) ? statsData.values.mes : [];
      // ‚úÖ Ordenar cronol√≥gicamente: junio 2025 a enero 2026
      const ordenMeses = ['junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre', 'enero'];
      const mesesOrdenados = mesesBase.sort((a, b) => {
        const idxA = ordenMeses.indexOf(a.toLowerCase());
        const idxB = ordenMeses.indexOf(b.toLowerCase());
        return (idxA === -1 ? 999 : idxA) - (idxB === -1 ? 999 : idxB);
      });

      let resumen = {};
      mesesOrdenados.forEach(mes => {
        resumen[mes] = {
          Atendido: getStatsCount(statsData.global, filtroTipo, 'Atendido', mes),
          Pendiente: getStatsCount(statsData.global, filtroTipo, 'Pendiente', mes),
          "En atenci√≥n": getStatsCount(statsData.global, filtroTipo, 'En atenci√≥n', mes),
          "No compete": getStatsCount(statsData.global, filtroTipo, 'No compete', mes),
          PendientesMes: 0,
          PendientesAcumulado: 0,
          IndicadorDias: 0
        };
      });

      let acumulado = 0;
      let totalMeses = mesesOrdenados.length;
      mesesOrdenados.forEach((m, idx) => {
        const fila = resumen[m];
        fila.PendientesMes = fila.Pendiente + fila["En atenci√≥n"];
        acumulado += fila.PendientesMes;
        fila.PendientesAcumulado = acumulado;

        let distanciaDesdeFinal = (totalMeses - 1) - idx;
        let factor = distanciaDesdeFinal * 30;
        if (distanciaDesdeFinal === 0) factor = 1;
        fila.IndicadorDias = fila.PendientesMes * factor;
      });

      let tabla = `<table class="table table-striped">
        <thead><tr>
          <th>Mes</th><th>Atendido</th><th>Pendiente</th><th>En atencion</th>
          <th>No compete</th><th>Total por Mes</th><th>% Atencion</th><th>Pendientes/En atencion</th>
          <th>Pendientes/En atencion (Acumulado)</th>
          <th>${filtroTipo && filtroTipo !== 'Todos' ? `Indicador d√≠as ${filtroTipo}` : 'Indicador de d√≠as por solicitudes'}</th>
        </tr></thead><tbody>`;

      let totalAtendido = 0, totalPendiente = 0, totalEnAtencion = 0, totalNoCompete = 0;
      let totalPendMes = 0, totalPendAcum = 0, totalIndicador = 0, totalPorMesSum = 0;

      mesesOrdenados.forEach((m, idx) => {
        const r = resumen[m];
        const nombreMes = m.charAt(0).toUpperCase() + m.slice(1);
        const totalMes = r.Atendido + r.Pendiente + r["En atenci√≥n"] + r["No compete"];
        const porcentajeAtencion = totalMes > 0 ? ((r.Atendido / totalMes) * 100).toFixed(1) : 0;

        // A√±adir a√±o: 2025 para jun-dic, 2026 para enero
        const esEnero = m.toLowerCase() === 'enero';
        const a√±oMostrar = esEnero ? 2026 : 2025;
        const etiquetaMes = `${nombreMes} ${a√±oMostrar}`;

        tabla += `<tr>
          <td>${etiquetaMes}</td>
          <td>${r.Atendido.toLocaleString('es-MX')}</td>
          <td>${r.Pendiente.toLocaleString('es-MX')}</td>
          <td>${r["En atenci√≥n"].toLocaleString('es-MX')}</td>
          <td>${r["No compete"].toLocaleString('es-MX')}</td>
          <td><strong>${totalMes.toLocaleString('es-MX')}</strong></td>
          <td><strong>${porcentajeAtencion}%</strong></td>
          <td>${r.PendientesMes.toLocaleString('es-MX')}</td>
          <td>${r.PendientesAcumulado.toLocaleString('es-MX')}</td>
          <td>${r.IndicadorDias.toLocaleString('es-MX')}</td>
        </tr>`;

        totalAtendido += r.Atendido;
        totalPendiente += r.Pendiente;
        totalEnAtencion += r["En atenci√≥n"];
        totalNoCompete += r["No compete"];
        totalPorMesSum += totalMes;
        totalPendMes += r.PendientesMes;
        totalPendAcum = r.PendientesAcumulado;
        totalIndicador += r.IndicadorDias;
      });

      const porcentajeTotal = totalPorMesSum > 0 ? ((totalAtendido / totalPorMesSum) * 100).toFixed(1) : 0;

      tabla += `<tr style="font-weight:bold;">
        <td>Total</td>
        <td>${totalAtendido.toLocaleString('es-MX')}</td>
        <td>${totalPendiente.toLocaleString('es-MX')}</td>
        <td>${totalEnAtencion.toLocaleString('es-MX')}</td>
        <td>${totalNoCompete.toLocaleString('es-MX')}</td>
        <td><strong>${totalPorMesSum.toLocaleString('es-MX')}</strong></td>
        <td><strong>${porcentajeTotal}%</strong></td>
        <td>${totalPendMes.toLocaleString('es-MX')}</td>
        <td>-</td>
        <td>-</td>
      </tr>`;

      tabla += `</tbody></table>`;
      document.getElementById("tablaResumen").innerHTML = tabla;
      setTimeout(() => {
        const tablaEl = document.querySelector('#tablaResumen table');
        if (tablaEl) habilitarSeleccionEnTabla(tablaEl);
      }, 50);
      return;
    }

    // ‚úÖ OPTIMIZACI√ìN: Usar obtenerIdsFiltrados() en lugar de .filter()
    const filtroTipoLook = (filtroTipo && filtroTipo !== 'Todos') ? filtroTipo : null;
    const idsFiltrados = obtenerIdsFiltrados(filtroTipoLook, null, null, false);
    
    console.log(`üìä generarTablaResumen: Procesando ${idsFiltrados.length} solicitudes`);
    
    let resumen = {};
    idsFiltrados.forEach(id => {
      const s = solicitudPorId[id];
      if(!s || !s["Fecha reporte"] || !s["Estado Reporte"]) return;
      
      let fecha = new Date(s["Fecha reporte"]);
      if(isNaN(fecha)) return;

      // clave por a√±o-mes
      let mesClave = fecha.getFullYear()+"-"+(fecha.getMonth()+1).toString().padStart(2,"0");
      if(!resumen[mesClave]) {
        resumen[mesClave] = {
          Atendido:0,
          Pendiente:0,
          "En atenci√≥n":0,
          "No compete":0,
          PendientesMes:0,
          PendientesAcumulado:0,
          IndicadorDias:0
        };
      }

      let estado = s["Estado Reporte"].trim();
      if(estado==="Pendiente"){
        resumen[mesClave].Pendiente++;
      } else if(estado==="En atenci√≥n"){
        resumen[mesClave]["En atenci√≥n"]++;
      } else if(estado==="Atendido"){
        resumen[mesClave].Atendido++;
      } else if(estado==="No compete"){
        resumen[mesClave]["No compete"]++;
      }
    });

    // Orden cronol√≥gico de meses: junio 2025 a enero 2026
    let mesesOrdenados = Object.keys(resumen).sort((a, b) => {
      // Formato esperado: YYYY-MM
      const [yearA, monthA] = a.split('-').map(Number);
      const [yearB, monthB] = b.split('-').map(Number);
      
      // Comparar por a√±o primero, luego por mes
      if (yearA !== yearB) return yearA - yearB;
      return monthA - monthB;
    });

    // Calcular Pendientes/En Atenci√≥n, acumulado y el indicador din√°mico
    let acumulado = 0;
    let totalMeses = mesesOrdenados.length;
    mesesOrdenados.forEach((m, idx) => {
      const fila = resumen[m];
      fila.PendientesMes = fila.Pendiente + fila["En atenci√≥n"];
      acumulado += fila.PendientesMes;
      fila.PendientesAcumulado = acumulado;

      // Factor din√°mico: √∫ltimo mes = 1, hacia atr√°s +30 cada vez
      let distanciaDesdeFinal = (totalMeses - 1) - idx;
      let factor = distanciaDesdeFinal * 30;
      if (distanciaDesdeFinal === 0) factor = 1; // √∫ltimo mes = 1
      fila.IndicadorDias = fila.PendientesMes * factor;
    });

    // Renderizar tabla
    let tabla = `<table class="table table-striped">
      <thead><tr>
        <th>Mes</th><th>Atendido</th><th>Pendiente</th><th>En atenci√≥n</th>
        <th>No compete</th><th>Total por Mes</th><th>% Atenci√≥n</th><th>Pendientes/En Atenci√≥n</th>
        <th>Pendientes/En Atenci√≥n (Acumulado)</th>
        <th>${filtroTipo && filtroTipo !== 'Todos' ? `Indicador d√≠as ${filtroTipo}` : 'Indicador de d√≠as por solicitudes'}</th>
      </tr></thead><tbody>`;

    // Variables para totales
    let totalAtendido = 0, totalPendiente = 0, totalEnAtencion = 0, totalNoCompete = 0;
    let totalPendMes = 0, totalPendAcum = 0, totalIndicador = 0, totalPorMesSum = 0;

    mesesOrdenados.forEach(m => {
      const r = resumen[m];
      const [anio, mesNum] = m.split("-");
      let nombreMes = new Date(anio, parseInt(mesNum)-1).toLocaleString('es-ES',{month:'long'});
      nombreMes = nombreMes.charAt(0).toUpperCase() + nombreMes.slice(1);

      const totalMes = r.Atendido + r.Pendiente + r["En atenci√≥n"] + r["No compete"];
      const porcentajeAtencion = totalMes > 0 ? ((r.Atendido / totalMes) * 100).toFixed(1) : 0;
      
      // Determinar a√±o: si es enero y viene despu√©s de diciembre = 2026
      const esEnero = nombreMes.toLowerCase() === 'enero';
      const a√±oMostrar = (esEnero && idx > 0) ? 2026 : anio;
      
      tabla += `<tr>
        <td>${nombreMes} ${a√±oMostrar}</td>
        <td>${r.Atendido.toLocaleString('es-MX')}</td>
        <td>${r.Pendiente.toLocaleString('es-MX')}</td>
        <td>${r["En atenci√≥n"].toLocaleString('es-MX')}</td>
        <td>${r["No compete"].toLocaleString('es-MX')}</td>
        <td><strong>${totalMes.toLocaleString('es-MX')}</strong></td>
        <td><strong>${porcentajeAtencion}%</strong></td>
        <td>${r.PendientesMes.toLocaleString('es-MX')}</td>
        <td>${r.PendientesAcumulado.toLocaleString('es-MX')}</td>
        <td>${r.IndicadorDias.toLocaleString('es-MX')}</td>
      </tr>`;

      // Acumular totales
      totalAtendido += r.Atendido;
      totalPendiente += r.Pendiente;
      totalEnAtencion += r["En atenci√≥n"];
      totalNoCompete += r["No compete"];
      totalPorMesSum += totalMes;
      totalPendMes += r.PendientesMes;
      totalPendAcum = r.PendientesAcumulado; // el acumulado final es el √∫ltimo valor
      totalIndicador += r.IndicadorDias;
    });

    // Calcular porcentaje total
    const porcentajeTotal = totalPorMesSum > 0 ? ((totalAtendido / totalPorMesSum) * 100).toFixed(1) : 0;

    // Fila de totales en negritas
    tabla += `<tr style="font-weight:bold;">
      <td>Total</td>
      <td>${totalAtendido.toLocaleString('es-MX')}</td>
      <td>${totalPendiente.toLocaleString('es-MX')}</td>
      <td>${totalEnAtencion.toLocaleString('es-MX')}</td>
      <td>${totalNoCompete.toLocaleString('es-MX')}</td>
      <td><strong>${totalPorMesSum.toLocaleString('es-MX')}</strong></td>
      <td><strong>${porcentajeTotal}%</strong></td>
      <td>${totalPendMes.toLocaleString('es-MX')}</td>
      <td>-</td>
      <td>-</td>
    </tr>`;

    tabla += `</tbody></table>`;
    document.getElementById("tablaResumen").innerHTML = tabla;
    
    // Habilitar selecci√≥n de celdas con estad√≠sticas (esperar a que el DOM se actualice)
    setTimeout(() => {
      const tabla = document.querySelector('#tablaResumen table');
      if (tabla) habilitarSeleccionEnTabla(tabla);
    }, 50);
  }

  // ========== GENERAR TABLA SECCIONES ==========
  // Tabla de secciones (atributo "transi") por mes
  // Solo se afecta por filtro de Tipo, ignora Estado y Mes
  function generarTablaSecciones(filtroTipo){
    // ‚ö†Ô∏è NOTA: statsData usa "seccion" pero necesitamos "transi"
    // Por ahora siempre usamos el procesamiento manual para garantizar transi
    const usarStatsData = false; // Deshabilitado hasta regenerar stats con transi
    
    if (usarStatsData && statsData && statsLoaded) {
      const mesesBase = (statsData.values && statsData.values.mes) ? statsData.values.mes : [];
      const estadoCols = ["Pendiente", "En atenci√≥n", "Atendido", "No compete"];

      const resumen = {};
      const seccionesEntries = Object.keys(statsData.secciones || {}).map(key => {
        const entry = statsData.secciones[key];
        return { key, label: entry.label || key };
      });

      seccionesEntries.forEach(sec => {
        resumen[sec.label] = {};
        mesesBase.forEach(mes => {
          resumen[sec.label][mes] = { Atendido: 0, Pendiente: 0, "En atenci√≥n": 0, "No compete": 0 };
          estadoCols.forEach(estado => {
            const key = `${mes}|${filtroTipo}|${estado}`;
            const val = (filtroTipo && filtroTipo !== 'Todos')
              ? (statsData.secciones[sec.key].mes_tipo_estado[key] || 0)
              : (statsData.secciones[sec.key].mes_estado[`${mes}|${estado}`] || 0);
            resumen[sec.label][mes][estado] = val;
          });
        });
      });

      let mesesOrdenados = mesesBase;
      let transiciones = seccionesEntries.map(s => s.label);

      let tabla = `<table class="table table-striped" style="font-size:11px;">
        <thead><tr>
          <th>Tipo de Secci√≥n</th>`;
      mesesOrdenados.forEach(m => {
        const nombreMes = m.charAt(0).toUpperCase() + m.slice(1);
        tabla += `<th>${nombreMes}</th>`;
      });
      tabla += `</tr></thead><tbody>`;

      transiciones.forEach(seccion => {
        tabla += `<tr><td><strong>${seccion}</strong></td>`;
        mesesOrdenados.forEach(m => {
          const data = resumen[seccion][m];
          const total = data.Atendido + data.Pendiente + data["En atenci√≥n"] + data["No compete"];
          tabla += `<td>${total > 0 ? total.toLocaleString('es-MX') : '-'}</td>`;
        });
        tabla += `</tr>`;
      });

      tabla += `</tbody></table>`;
      document.getElementById("tablaSecciones").innerHTML = tabla;
      setTimeout(() => {
        const tablaEl = document.querySelector('#tablaSecciones table');
        if (tablaEl) habilitarSeleccionEnTabla(tablaEl);
      }, 50);
      return;
    }

    // ‚úÖ OPTIMIZACI√ìN: Usar obtenerIdsFiltrados() en lugar de .filter()
    const filtroTipoLook = (filtroTipo && filtroTipo !== 'Todos') ? filtroTipo : null;
    const idsFiltrados = obtenerIdsFiltrados(filtroTipoLook, null, null, false);
    
    console.log(`üìä generarTablaSecciones: Procesando ${idsFiltrados.length} solicitudes`);
    
    let resumen = {}; // { "seccion": { "2025-01": { Atendido: n, Pendiente: n, ... } } }
    let mesesSet = new Set();
    
    idsFiltrados.forEach(id => {
      const s = solicitudPorId[id];
      if(!s) return; // Solo descartar si no existe el registro
      
      // Procesar incluso si falta fecha o estado (usar valores por defecto)
      let fecha = null;
      let mesClave = "desconocido";
      if(s["Fecha reporte"]) {
        fecha = new Date(s["Fecha reporte"]);
        if(!isNaN(fecha)) {
          mesClave = fecha.getFullYear()+"-"+(fecha.getMonth()+1).toString().padStart(2,"0");
        }
      }
      mesesSet.add(mesClave);
      
      // ‚úÖ USAR SOLO transi (las 7 transiciones: AA, AB, BA, BB, CA, CC, DD)
      // Las solicitudes sin transi van a "Sin secci√≥n"
      const seccionValor = s["transi"] || "Sin secci√≥n";
      const seccionNorm = normalizeSeccionKey(seccionValor);
      const seccionNormFinal = seccionNorm || "Sin secci√≥n";
      
      // Usar estado si existe, sino usar "Desconocido"
      const estado = (s["Estado Reporte"] || "Desconocido").trim();
      
      if(!resumen[seccionNormFinal]) {
        resumen[seccionNormFinal] = {};
      }
      if(!resumen[seccionNormFinal][mesClave]) {
        resumen[seccionNormFinal][mesClave] = { Atendido: 0, Pendiente: 0, "En atenci√≥n": 0, "No compete": 0, Desconocido: 0 };
      }
      
      if(estado==="Pendiente"){
        resumen[seccionNormFinal][mesClave].Pendiente++;
      } else if(estado==="En atenci√≥n"){
        resumen[seccionNormFinal][mesClave]["En atenci√≥n"]++;
      } else if(estado==="Atendido"){
        resumen[seccionNormFinal][mesClave].Atendido++;
      } else if(estado==="No compete"){
        resumen[seccionNormFinal][mesClave]["No compete"]++;
      } else {
        resumen[seccionNormFinal][mesClave].Desconocido++;
      }
    });
    
    // Ordenar meses cronol√≥gicamente
    let mesesOrdenados = Array.from(mesesSet).sort();
    
    // Ordenar transiciones en orden espec√≠fico: AA, BA, CA, AB, BB, CC, DD, Sin secci√≥n
    const ordenEspecifico = ["AA", "BA", "CA", "AB", "BB", "CC", "DD", "Sin secci√≥n"];
    const seccionesKeys = Object.keys(resumen);

    let transiciones = seccionesKeys.sort((a, b) => {
      const idxA = ordenEspecifico.indexOf(a);
      const idxB = ordenEspecifico.indexOf(b);
      // Si ambas est√°n en el orden espec√≠fico, usar ese orden
      if (idxA !== -1 && idxB !== -1) return idxA - idxB;
      // Si solo una est√° en el orden, la que est√° en el orden va primero
      if (idxA !== -1) return -1;
      if (idxB !== -1) return 1;
      // Si ninguna est√° en el orden, ordenar alfab√©ticamente
      return a.localeCompare(b, 'es', { numeric: true, sensitivity: 'base' });
    });
    
    if(transiciones.length === 0 || mesesOrdenados.length === 0) {
      document.getElementById("tablaSecciones").innerHTML = "<p>No hay datos disponibles</p>";
      return;
    }
    
    // Construir tabla
    let tabla = `<table class="table table-striped">
      <thead><tr>
        <th>Tipo de Secci√≥n</th>`;
    
    // Headers de meses
    mesesOrdenados.forEach(m => {
      const [anio, mesNum] = m.split("-");
      let nombreMes = new Date(anio, parseInt(mesNum)-1).toLocaleString('es-ES',{month:'short'});
      nombreMes = nombreMes.charAt(0).toUpperCase() + nombreMes.slice(1);
      tabla += `<th>${nombreMes} ${anio}</th>`;
    });
    
    tabla += `<th>Total</th><th>% Atenci√≥n</th></tr></thead><tbody>`;
    
    // Variables para totales por columna (mes)
    let totalesPorMes = {};
    mesesOrdenados.forEach(m => {
      totalesPorMes[m] = 0;
    });
    let totalGeneral = 0;
    let totalAtendidoGeneral = 0;
    
    // Filas de cada transici√≥n
    transiciones.forEach(transi => {
      tabla += `<tr><td>${transi}</td>`;
      
      let totalFila = 0;
      let atendidoFila = 0;
      
      mesesOrdenados.forEach(m => {
        const datos = resumen[transi][m] || { Atendido: 0, Pendiente: 0, "En atenci√≥n": 0, "No compete": 0 };
        const totalCelda = datos.Atendido + datos.Pendiente + datos["En atenci√≥n"] + datos["No compete"];
        
        tabla += `<td>${totalCelda > 0 ? totalCelda.toLocaleString('es-MX') : ''}</td>`;
        
        totalFila += totalCelda;
        atendidoFila += datos.Atendido;
        totalesPorMes[m] += totalCelda;
      });
      
      const porcentajeAtencion = totalFila > 0 ? ((atendidoFila / totalFila) * 100).toFixed(1) : 0;
      
      tabla += `<td><strong>${totalFila.toLocaleString('es-MX')}</strong></td>`;
      tabla += `<td><strong>${porcentajeAtencion}%</strong></td>`;
      tabla += `</tr>`;
      
      totalGeneral += totalFila;
      totalAtendidoGeneral += atendidoFila;
    });
    
    // Fila de totales
    tabla += `<tr style="font-weight:bold;"><td>Total</td>`;
    
    mesesOrdenados.forEach(m => {
      tabla += `<td>${totalesPorMes[m].toLocaleString('es-MX')}</td>`;
    });
    
    const porcentajeTotal = totalGeneral > 0 ? ((totalAtendidoGeneral / totalGeneral) * 100).toFixed(1) : 0;
    
    tabla += `<td><strong>${totalGeneral.toLocaleString('es-MX')}</strong></td>`;
    tabla += `<td><strong>${porcentajeTotal}%</strong></td>`;
    tabla += `</tr></tbody></table>`;
    
    document.getElementById("tablaSecciones").innerHTML = tabla;
    
    // Habilitar selecci√≥n de celdas con estad√≠sticas
    setTimeout(() => {
      const tabla = document.querySelector('#tablaSecciones table');
      if (tabla) habilitarSeleccionEnTabla(tabla);
    }, 50);
  }

  // ========== INICIALIZADOR FILTROS ==========
  function inicializarFiltros() {
    let tiposUnicos = (statsData && statsData.values && statsData.values.tipo)
      ? statsData.values.tipo
      : [...new Set(solicitudes.map(s => s["Tipo de reporte"]).filter(Boolean))];
    let selectTipo = document.getElementById("filtroTipo");
    tiposUnicos.forEach(t => {
      let opt = document.createElement("option");
      opt.value = t;
      opt.textContent = t;
      selectTipo.appendChild(opt);
    });

    let estadosUnicos = (statsData && statsData.values && statsData.values.estado)
      ? statsData.values.estado
      : [...new Set(solicitudes.map(s => s["Estado Reporte"]).filter(Boolean))];
    let selectEstado = document.getElementById("filtroEstado");
    estadosUnicos.forEach(e => {
      let opt = document.createElement("option");
      opt.value = e;
      opt.textContent = e;
      selectEstado.appendChild(opt);
    });

    // Extraer meses √∫nicos con a√±o para ordenar cronol√≥gicamente
    let mesesConAnioSet = new Set();
    let mesesConMetadata = new Map(); // Guardar a√±o para cada mes
    
    solicitudes.forEach(s => {
      if (!s["Fecha reporte"]) return;
      let fecha = new Date(s["Fecha reporte"]);
      if (isNaN(fecha)) return;
      
      const mes = fecha.getMonth(); // 0-11
      const anio = fecha.getFullYear();
      const nombresMeses = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio',
                            'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'];
      const mesNombre = nombresMeses[mes];
      const claveTiempo = `${anio}-${(mes + 1).toString().padStart(2, '0')}`; // "2025-06" para ordenar
      
      mesesConAnioSet.add(claveTiempo);
      if (!mesesConMetadata.has(mesNombre)) {
        mesesConMetadata.set(mesNombre, []);
      }
      if (!mesesConMetadata.get(mesNombre).includes(anio)) {
        mesesConMetadata.get(mesNombre).push(anio);
      }
    });
    
    // Ordenar cronol√≥gicamente (ascendente: junio 2025 primero, enero 2026 al final)
    let mesesOrdenados = Array.from(mesesConAnioSet).sort((a, b) => {
      const [yearA, monthA] = a.split('-').map(Number);
      const [yearB, monthB] = b.split('-').map(Number);
      if (yearA !== yearB) return yearA - yearB;
      return monthA - monthB;
    });
    
    // Convertir a formato legible y preparar opciones
    const nombresCompletos = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
                              'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
    const nombresMinusculas = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio',
                               'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'];
    
    let mesesFormateados = mesesOrdenados.map(clave => {
      const [year, month] = clave.split('-').map(Number);
      return {
        valor: nombresMinusculas[month - 1], // Usar nombre mes min.para filtrado ("junio")
        label: `${nombresCompletos[month - 1]} ${year}` // Mostrar "Junio 2025"
      };
    });

    let selectMes = document.getElementById("filtroMes");
    mesesFormateados.forEach(m => {
      let opt = document.createElement("option");
      opt.value = m.valor; // Usar "junio", "julio", etc.
      opt.textContent = m.label; // Mostrar "Junio 2025"
      selectMes.appendChild(opt);
    });
  }

  // ========== CARGAR DATOS ==========
  console.log("Iniciando carga de datos...");
  
  // Protecci√≥n contra recargas infinitas
  if (!window.__loadAttempt) {
    window.__loadAttempt = 0;
  }
  window.__loadAttempt++;
  console.log("Intento de carga #" + window.__loadAttempt);
  if (window.__loadAttempt > 5) {
    console.error("ERROR CR√çTICO: Demasiados intentos de carga. Posible loop infinito detectado.");
    // Usar Storage para persistir el error
  }
  
  // Mostrar overlay de carga al iniciar
  try { if (typeof showLoading === 'function') showLoading(); } catch(e){}
  
  let coloniasLoaded = false;
  let solicitudesLoaded = false;

  function iniciarSiTodoEstaListo() {
    console.log(`üìä iniciarSiTodoEstaListo() check: colonias=${coloniasLoaded}, solicitudes=${solicitudesLoaded}, stats=${statsLoaded}`);
    if (coloniasLoaded && solicitudesLoaded && statsLoaded) {
      console.log("‚úÖ TODOS LOS DATOS CARGADOS");
      precalcularIndices();
      inicializarFiltros();
      renderizar("Todos", "Todos", "Todos");
      console.log("‚úÖ Inicializaci√≥n completa");
      
      // ‚úÖ Mostrar el contador de solicitudes ahora que los datos est√°n completos
      const contadorEl = document.getElementById('contadorSolicitudes');
      if (contadorEl) {
        contadorEl.style.display = 'block';
      }
      
      // Mostrar m√©tricas de startup
      mostrarMetricasStartup();
      
      // Exponer datos globalmente para consultas
      window.datosSolicitudes = solicitudes;
      window.obtenerDatosParaIA = obtenerDatosParaIA;
      
      // Exponer funciones helper para consultas de IA
      if (typeof window.exponerFuncionesHelper === 'function') {
        window.exponerFuncionesHelper();
      }
      
      // ‚úÖ NO ocultar loading aqu√≠ - dejamos que renderizar() lo maneje con su propio timeout
      // try { if (typeof hideLoading === 'function') hideLoading(); } catch(e){}
    }
  }

  function mostrarMetricasStartup() {
    const totalSolicitudes = solicitudes.length;
    
    // Usar stats precalculadas si est√°n disponibles
    if (statsData && statsData.coords) {
      const coordsStats = statsData.coords;
      console.log("üìä M√âTRICAS DE STARTUP:");
      console.log(`   Total solicitudes: ${coordsStats.total}`);
      console.log(`   Con coordenadas v√°lidas: ${coordsStats.with_coords}`);
      console.log(`   Sin coordenadas: ${coordsStats.missing_both}`);
      console.log(`   Con coordenadas inv√°lidas: ${coordsStats.invalid_coords}`);
    } else {
      console.log("üìä M√âTRICAS DE STARTUP:");
      console.log(`   Total solicitudes: ${totalSolicitudes}`);
    }

    if (statsData?.meta?.vialidades) {
      console.log(`   Vialidades primarias: ${statsData.meta.vialidades.primarias}`);
      console.log(`   Vialidades locales: ${statsData.meta.vialidades.locales}`);
      return;
    }

    if (isIOS) {
      console.log("   M√©tricas detalladas de vialidades omitidas en iOS por rendimiento");
      return;
    }

    console.log("   Vialidades layer no disponible a√∫n para c√°lculo");
  }

  // ========== FUNCI√ìN PARA OBTENER DATOS PROCESADOS ==========
  function obtenerDatosParaIA() {
    return {
      solicitudes: solicitudes,
      totalSolicitudes: solicitudes.length,
      colonias: [...new Set(solicitudes.map(s => s.Colonia).filter(c => c && c !== "Sin colonia"))],
      secciones: [...new Set(solicitudes.map(s => s.seccion || s.SECCION).filter(Boolean))],
      tiposReporte: [...new Set(solicitudes.map(s => s["Tipo de reporte"]).filter(Boolean))],
      estados: [...new Set(solicitudes.map(s => s["Estado Reporte"]).filter(Boolean))]
    };
  }

  function iniciarCargaGeoportal() {
    if (geoportalDataStarted) return;
    geoportalDataStarted = true;
    window.exponerFuncionesHelper = exponerFuncionesHelper;
    inicializarMapaSiNecesario();

    // ========== CARGAR ESTADISTICAS PRECALCULADAS ===========
    fetch("archivos/precalculos/estadisticas.json")
    .then(res => res.json())
    .then(data => {
      statsData = data;
      statsLoaded = true;
      console.log("‚úÖ Estadisticas precalculadas cargadas");
      
      // Actualizar displays de vialidades desde prec√°lculos
      if (data.meta && data.meta.vialidades) {
        const vial = data.meta.vialidades;
        const spanPrimarias = document.getElementById("vialidadesPrimarias");
        const spanLocales = document.getElementById("vialidadesLocales");
        if (spanPrimarias) spanPrimarias.textContent = vial.primarias.toLocaleString('es-MX');
        if (spanLocales) spanLocales.textContent = vial.locales.toLocaleString('es-MX');
        console.log(`üìç Mostrando vialidades: Primarias=${vial.primarias}, Locales=${vial.locales}`);
      }
      
      iniciarSiTodoEstaListo();
    })
    .catch(err => {
      console.error("Error al cargar estadisticas precalculadas:", err);
      statsLoaded = true; // Fallback para no bloquear
      iniciarSiTodoEstaListo();
    });

  // ========== FUNCIONES HELPER PARA CONSULTAS DE IA ==========
  function exponerFuncionesHelper() {
    // Funci√≥n para obtener top N secciones por tipo de reporte
    window.getTopSeccionesPorTipo = function(tipoReporte, topN = 10) {
      const datos = solicitudes.filter(s => {
        const tipo = s["Tipo de reporte"];
        return tipo && tipo.toLowerCase().includes(tipoReporte.toLowerCase());
      });
      
      const seccionCount = {};
      datos.forEach(s => {
        const seccion = s.seccion || s.SECCION;
        if (seccion) {
          const secStr = String(seccion).trim();
          seccionCount[secStr] = (seccionCount[secStr] || 0) + 1;
        }
      });
      
      const resultado = Object.entries(seccionCount)
        .map(([seccion, total]) => ({ seccion, total }))
        .sort((a, b) => b.total - a.total)
        .slice(0, topN);
      
      console.table(resultado);
      return resultado;
    };
    
    // Funci√≥n para obtener top N colonias por tipo de reporte
    window.getTopColoniasPorTipo = function(tipoReporte, topN = 10) {
      const datos = solicitudes.filter(s => {
        const tipo = s["Tipo de reporte"];
        return tipo && tipo.toLowerCase().includes(tipoReporte.toLowerCase());
      });
      
      const coloniaCount = {};
      datos.forEach(s => {
        const colonia = s.Colonia;
        if (colonia && colonia !== "Sin colonia" && colonia !== "sin colonia") {
          coloniaCount[colonia] = (coloniaCount[colonia] || 0) + 1;
        }
      });
      
      const resultado = Object.entries(coloniaCount)
        .map(([colonia, total]) => ({ colonia, total }))
        .sort((a, b) => b.total - a.total)
        .slice(0, topN);
      
      console.table(resultado);
      return resultado;
    };
    
    // Funci√≥n mejorada: Top colonias con baches por estado
    window.getTopColoniasBachesPorEstado = function(topN = 10) {
      const datos = solicitudes.filter(s => {
        const tipo = s["Tipo de reporte"] || "";
        return tipo.toLowerCase().includes("bache");
      });
      
      const coloniaStats = {};
      datos.forEach(s => {
        const colonia = s.Colonia;
        const estado = s["Estado Reporte"] || "Sin estado";
        
        if (colonia && colonia !== "Sin colonia") {
          if (!coloniaStats[colonia]) {
            coloniaStats[colonia] = { 
              Pendiente: 0, 
              Atendido: 0, 
              "En atenci√≥n": 0, 
              "No compete": 0,
              Total: 0
            };
          }
          coloniaStats[colonia][estado] = (coloniaStats[colonia][estado] || 0) + 1;
          coloniaStats[colonia].Total++;
        }
      });
      
      const resultado = Object.entries(coloniaStats)
        .map(([colonia, stats]) => ({ colonia, ...stats }))
        .sort((a, b) => b.Total - a.Total)
        .slice(0, topN);
      
      console.table(resultado);
      
      // Generar HTML
      let html = `<h4>Top ${topN} Colonias con m√°s Baches por Estado</h4>
        <table class="table table-striped">
          <thead><tr>
            <th>Colonia</th>
            <th>Pendiente</th>
            <th>En atenci√≥n</th>
            <th>Atendido</th>
            <th>No compete</th>
            <th>Total</th>
          </tr></thead><tbody>`;
      
      resultado.forEach(r => {
        html += `<tr>
          <td>${r.colonia}</td>
          <td>${r.Pendiente}</td>
          <td>${r["En atenci√≥n"]}</td>
          <td>${r.Atendido}</td>
          <td>${r["No compete"]}</td>
          <td><strong>${r.Total}</strong></td>
        </tr>`;
      });
      
      html += `</tbody></table>`;
      console.log("HTML generado. Copia este c√≥digo:");
      console.log(html);
      
      return { datos: resultado, html: html };
    };
    
    // Funci√≥n mejorada: Top secciones con solicitudes por estado
    window.getTopSeccionesPorEstado = function(topN = 10) {
      const seccionStats = {};
      
      solicitudes.forEach(s => {
        const seccion = s.seccion || s.SECCION;
        const estado = s["Estado Reporte"] || "Sin estado";
        
        if (seccion) {
          const secStr = String(seccion).trim();
          if (!seccionStats[secStr]) {
            seccionStats[secStr] = { 
              Pendiente: 0, 
              Atendido: 0, 
              "En atenci√≥n": 0, 
              "No compete": 0,
              Total: 0
            };
          }
          seccionStats[secStr][estado] = (seccionStats[secStr][estado] || 0) + 1;
          seccionStats[secStr].Total++;
        }
      });
      
      const resultado = Object.entries(seccionStats)
        .map(([seccion, stats]) => ({ seccion, ...stats }))
        .sort((a, b) => b.Total - a.Total)
        .slice(0, topN);
      
      console.table(resultado);
      
      // Generar HTML
      let html = `<h4>Top ${topN} Secciones con m√°s Solicitudes por Estado</h4>
        <table class="table table-striped">
          <thead><tr>
            <th>Secci√≥n</th>
            <th>Pendiente</th>
            <th>En atenci√≥n</th>
            <th>Atendido</th>
            <th>No compete</th>
            <th>Total</th>
          </tr></thead><tbody>`;
      
      resultado.forEach(r => {
        html += `<tr>
          <td>${r.seccion}</td>
          <td>${r.Pendiente}</td>
          <td>${r["En atenci√≥n"]}</td>
          <td>${r.Atendido}</td>
          <td>${r["No compete"]}</td>
          <td><strong>${r.Total}</strong></td>
        </tr>`;
      });
      
      html += `</tbody></table>`;
      console.log("HTML generado. Copia este c√≥digo:");
      console.log(html);
      
      return { datos: resultado, html: html };
    };
    
    // Funci√≥n para obtener todos los tipos de reporte disponibles
    window.getTiposReporte = function() {
      const tipos = [...new Set(solicitudes.map(s => s["Tipo de reporte"]).filter(Boolean))].sort();
      console.log("Tipos de reporte disponibles:", tipos);
      return tipos;
    };
    
    // Funci√≥n para obtener estad√≠sticas generales
    window.getEstadisticasGenerales = function() {
      const stats = {
        totalSolicitudes: solicitudes.length,
        totalSecciones: new Set(solicitudes.map(s => s.seccion || s.SECCION).filter(Boolean)).size,
        totalColonias: new Set(solicitudes.map(s => s.Colonia).filter(Boolean)).size,
        tiposReporte: [...new Set(solicitudes.map(s => s["Tipo de reporte"]).filter(Boolean))].length,
        porEstado: {}
      };
      
      solicitudes.forEach(s => {
        const estado = s["Estado Reporte"];
        if (estado) {
          stats.porEstado[estado] = (stats.porEstado[estado] || 0) + 1;
        }
      });
      
      console.table(stats);
      return stats;
    };
    
    console.log("üìä Funciones helper disponibles:");
    console.log("  - getTopSeccionesPorTipo('baches', 10)");
    console.log("  - getTopColoniasPorTipo('baches', 10)");
    console.log("  - getTopColoniasBachesPorEstado(10) ‚≠ê RECOMENDADA");
    console.log("  - getTopSeccionesPorEstado(10) ‚≠ê RECOMENDADA");
    console.log("  - getTiposReporte()");
    console.log("  - getEstadisticasGenerales()");
  }

  // Cargar colonias
  fetch("archivos/precalculos/colonias_enriquecidas.geojson")
    .then(res => res.json())
    .then(data => {
      if (coloniasLayer) return; // Evitar duplicaci√≥n
      // Desactivado: mantemos geometr√≠a original para evitar deformaciones en m√≥vil
      
      coloniasLayer = L.geoJson(data, {
        renderer: L.canvas(),
        smoothFactor: 0,
        style: function(feature) {
          return {
            color: "#555",
            weight: 1,
            fill: true,
            fillColor: "#eee",
            fillOpacity: 0.6
          };
        },
        onEachFeature: function(feature, layer) {
          const nombreColonia = feature.properties.NOMBRE;
          // Guardar versi√≥n normalizada en la propiedad para comparaciones r√°pidas
          try { feature.properties._normName = normalizeKey(nombreColonia); } catch(e) { feature.properties._normName = null; }
          
          // Popup inicial simple, se actualizar√° al hacer clic
          layer.bindPopup(`<b>${nombreColonia}</b><br>Total Solicitudes: 0`);

          layer.on('click', function(e) {
            if (L && L.DomEvent) L.DomEvent.stopPropagation(e);

            if (selectedOutline) {
              map.removeLayer(selectedOutline);
              selectedOutline = null;
            }

            selectedOutline = L.geoJSON(layer.toGeoJSON(), {
              style: { color: "red", weight: 3, fill: false }
            }).addTo(map);

            if (selectedOutline.bringToFront) selectedOutline.bringToFront();

            layer.openPopup();
            seccionSeleccionada = null;
            coloniaSeleccionada = layer;
            // Renderizar respetando los filtros activos (no forzar 'Todos')
            try {
              const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
              const estado = document.getElementById('filtroEstado')?.value || 'Todos';
              const mes = document.getElementById('filtroMes')?.value || 'Todos';
              renderizar(tipo, estado, mes);
            } catch (e) {
              renderizar('Todos','Todos','Todos');
            }
          });

          layer.on('popupclose', function() {
            if (selectedOutline) {
              map.removeLayer(selectedOutline);
              selectedOutline = null;
            }
            if (coloniaSeleccionada === layer) {
              coloniaSeleccionada = null;
              // Restaurar la visualizaci√≥n previa llamando a renderizar con filtros actuales
              try {
                const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
                const estado = document.getElementById('filtroEstado')?.value || 'Todos';
                const mes = document.getElementById('filtroMes')?.value || 'Todos';
                renderizar(tipo, estado, mes);
              } catch (e) {
                renderizar('Todos','Todos','Todos');
              }
            }
          });
        }
      }).addTo(map);

      coloniasLayer.eachLayer(layer => {
        let nombre = layer.feature.properties.NOMBRE;
        let norm = layer.feature.properties._normName || normalizeKey(nombre);
        if (norm) normToColoniaName[norm] = nombre;
        if(nombre) {
          // Guardar para autocompletado
          coloniasList.push(nombre);
          let opt = document.createElement("option");
          opt.value = nombre;
          document.getElementById("sugerenciasColonias").appendChild(opt);
        }
      });

      // Dejar √∫nica y ordenada la lista de colonias
      try {
        coloniasList = Array.from(new Set(coloniasList)).sort((a,b)=>a.localeCompare(b,'es',{sensitivity:'base'}));
      } catch(e) {}

      coloniasLoaded = true;
      console.log("‚úÖ Colonias cargadas");
      // Inicializar el autocompletado una vez que tengamos colonias
      try { initializeAutocompleteFallback(); } catch(e) { console.log('Autocomplete init error', e); }
      iniciarSiTodoEstaListo();
    })
    .catch(err => console.error("Error al cargar colonias:", err));

  // Cargar secciones - SIMPLIFICADO PARA DEBUGGING
  const seccionesUrl = "archivos/precalculos/secciones_enriquecidas.geojson";
  console.log("üìç Intentando cargar secciones desde:", seccionesUrl);
  console.log("   Ubicaci√≥n base del servidor:", window.location.href);
  fetch(seccionesUrl)
    .then(res => {
      console.log("üì• Fetch de secciones OK, status:", res.status);
      if (!res.ok) {
        console.error("  ‚ùå Response no OK - Status:", res.status, res.statusText);
        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
      }
      return res.json();
    })
    .then(data => {
      console.log("üìä GeoJSON de secciones parseado. Features:", data.features?.length || 0);
      if (!data.features || data.features.length === 0) {
        throw new Error("GeoJSON no contiene features v√°lidas");
      }
      if (seccionesLayer) {
        console.log("‚ö†Ô∏è seccionesLayer ya existe, evitando duplicaci√≥n");
        return;
      }
      
      try {
        seccionesLayer = L.geoJson(data, {
          // SIN renderer canvas - usar SVG por defecto para debugging
          style: function(feature) {
            return {
              color: "#555",
              weight: 2,
              fill: true,
              fillColor: "#922B21",
              fillOpacity: 0.5
            };
          },
          onEachFeature: function(feature, layer) {
            try {
              // Debug: Verificar propiedades del primer feature
              if (!window.seccionDebugPrinted) {
                console.log('DEBUG: Primera secci√≥n del GeoJSON:', {
                  seccion_minuscula: feature.properties.seccion,
                  SECCION_mayuscula: feature.properties.SECCION,
                  todas_propiedades: Object.keys(feature.properties)
                });
                window.seccionDebugPrinted = true;
              }
              
              const nombreSeccion = feature.properties.seccion || feature.properties.SECCION || "Sin nombre";
              feature.properties._normName = normalizeSeccionKey(nombreSeccion);
              
              layer.bindPopup(`<b>Secci√≥n ${nombreSeccion}</b><br>Total Solicitudes: 0`);

              layer.on('click', function(e) {
                try {
                  if (L && L.DomEvent) L.DomEvent.stopPropagation(e);

                  if (selectedOutline) {
                    map.removeLayer(selectedOutline);
                    selectedOutline = null;
                  }

                  selectedOutline = L.geoJSON(layer.toGeoJSON(), {
                    style: { color: "red", weight: 3, fill: false }
                  }).addTo(map);

                  if (selectedOutline.bringToFront) selectedOutline.bringToFront();

                  layer.openPopup();
                  coloniaSeleccionada = null;
                  seccionSeleccionada = layer;
                  
                  const secNum = layer.feature?.properties?.seccion || layer.feature?.properties?.SECCION;
                  console.log('SECCI√ìN CLICKEADA:', secNum);
                  console.log('   seccionSeleccionada asignada:', seccionSeleccionada ? 'S√ç' : 'NO');
                  
                  try {
                    const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
                    const estado = document.getElementById('filtroEstado')?.value || 'Todos';
                    const mes = document.getElementById('filtroMes')?.value || 'Todos';
                    renderizar(tipo, estado, mes);
                  } catch (e) {
                    renderizar('Todos','Todos','Todos');
                  }
                } catch(ce) {
                  console.warn("Error en click de secci√≥n:", ce);
                }
              });

              layer.on('popupclose', function() {
                if (selectedOutline) {
                  map.removeLayer(selectedOutline);
                  selectedOutline = null;
                }
                if (seccionSeleccionada === layer) {
                  seccionSeleccionada = null;
                  
                  try {
                    const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
                    const estado = document.getElementById('filtroEstado')?.value || 'Todos';
                    const mes = document.getElementById('filtroMes')?.value || 'Todos';
                    renderizar(tipo, estado, mes);
                  } catch (e) {
                    renderizar('Todos','Todos','Todos');
                  }
                }
              });
            } catch(fe) {
              console.warn("Error procesando feature de secci√≥n:", fe);
            }
          }
        }); // NO agregar al mapa inicialmente, las secciones comienzan ocultas
        
        console.log("Secciones cargadas exitosamente en seccionesLayer");
      } catch(le) {
        console.error("Error al crear seccionesLayer:", le);
        throw le;
      }

      console.log("üó∫Ô∏è seccionesLayer creado con", seccionesLayer.getLayers().length, "layers");
      
      seccionesLayer.eachLayer(layer => {
        let nombre = layer.feature.properties.seccion || layer.feature.properties.SECCION || "Sin nombre";
        let norm = layer.feature.properties._normName || normalizeKey(nombre);
        if (norm) normToSeccionName[norm] = nombre;
        if(nombre && nombre !== "Sin nombre") {
          seccionesList.push(nombre);
        }
      });

      try {
        seccionesList = Array.from(new Set(seccionesList)).sort((a,b)=>a.localeCompare(b,'es',{sensitivity:'base'}));
      } catch(e) {}

      console.log("‚úÖ Secciones cargadas:", seccionesLayer.getLayers().length, "features");
      console.log("üìç Bounds de secciones:", seccionesLayer.getBounds());
      console.log("üó∫Ô∏è Lista de secciones:", seccionesList.slice(0, 5), "...");
      agregarControlesCapas();
      try {
        const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
        const estado = document.getElementById('filtroEstado')?.value || 'Todos';
        const mes = document.getElementById('filtroMes')?.value || 'Todos';
        renderizar(tipo, estado, mes);
      } catch (e) {
        console.log('Error actualizando render tras cargar secciones:', e);
      }
    })
    .catch(err => {
      console.error("Error al cargar secciones:", err);
      console.error("  Mensaje:", err.message);
      console.error("  Stack:", err.stack);
      // Continuar sin bloquear
      console.warn("Continuando sin secciones...");
    });

  // Cargar vialidades
  const vialidadesUrl = "./archivos/vectores/vialidades.geojson";
  console.log("Cargando vialidades...");
  console.log("üìç URL de vialidades:", vialidadesUrl, "(relativo a:", window.location.href, ")");
  fetch(vialidadesUrl)
    .then(res => {
      console.log("Respuesta de vialidades recibida, status:", res.status);
      if (!res.ok) {
        console.error("  ‚ùå Response no OK - Status:", res.status, res.statusText);
        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
      }
      return res.json();
    })
    .then(data => {
      console.log("JSON parseado correctamente");
      if (!data.features || data.features.length === 0) {
        throw new Error("GeoJSON de vialidades no contiene features v√°lidas");
      }
      if (vialidadesLayer) {
        console.log("Vialidades ya cargadas, saltando...");
        return;
      }
      
      console.log("Datos de vialidades parseados:", data.features ? data.features.length : 0, "features");
      console.log("‚úÖ Las coordenadas ya est√°n en WGS84, no se necesita transformaci√≥n");
      
      // Crear capa de vialidades con pol√≠gonos rellenos
      try {
        vialidadesLayer = L.geoJson(data, {
            style: function(feature) {
              return {
                fillColor: "#2563EB",    // Azul rey relleno
                fillOpacity: 0.5,        // Opacidad del relleno
                color: "#1E40AF",        // Borde azul m√°s oscuro
                weight: 1,               // Borde delgado
                opacity: 0.7
              };
            },
            onEachFeature: function(feature, layer) {
              try {
                // Si hay nombre de vialidad, mostrar en popup
                const nombre = feature.properties.NOMBRE || feature.properties.NOMENCLAT || feature.properties.NOMBREVIAL || 'Vialidad';
                const tipo = feature.properties.TIPO_VIA || '';
                layer.bindPopup(`<b>${nombre}</b>${tipo ? '<br>' + tipo : ''}`);
              } catch(fe) {
                console.warn("Error procesando feature de vialidad:", fe);
              }
            }
        }).addTo(map);
        console.log("‚úÖ vialidadesLayer a√±adida al mapa");
      } catch(e) {
        console.error("Error al crear vialidadesLayer:", e);
        throw e;
      }

      // Asegurar que las vialidades est√©n ENCIMA de todas las capas
      if (vialidadesLayer) {
        try {
          if (vialidadesLayer.bringToFront) {
            vialidadesLayer.bringToFront();
          }
          
          // Hacer zoom a las vialidades para verificar que se cargaron
          const bounds = vialidadesLayer.getBounds();
          console.log("Bounds de vialidades:", bounds);
          console.log("Vialidades visibles en el mapa:", map.hasLayer(vialidadesLayer));
          
          // Activar zoom temporal para verificar ubicaci√≥n
          setTimeout(() => {
            map.fitBounds(bounds);
            console.log("Zoom aplicado a vialidades");
          }, 2000);
        } catch (e) {
          console.warn("Error al procesar bounds de vialidades:", e);
        }
      }

      console.log("‚úÖ Vialidades cargadas y a√±adidas al mapa");
      console.log("Capas en el mapa:", map._layers);
    })
    .catch(err => {
      console.error("Error al cargar vialidades:", err);
      console.error("  Mensaje:", err.message);
      console.error("  Stack:", err.stack);
      console.warn("Continuando sin vialidades...");
      // No bloquear con alert - seguir adelante
    });

  // Cargar l√≠mite de alcald√≠a como capa de referencia
  fetch("./archivos/vectores/limite_alcaldia.geojson")
    .then(res => {
      console.log("Respuesta de l√≠mite de alcald√≠a recibida, status:", res.status);
      if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
      return res.json();
    })
    .then(data => {
      console.log("L√≠mite de alcald√≠a parseado correctamente");
      if (limiteAlcaldiaLayer) {
        console.log("L√≠mite de alcald√≠a ya cargado, saltando...");
        return;
      }
      
      console.log("Datos de l√≠mite de alcald√≠a parseados:", data.features ? data.features.length : 0, "features");
      
      // Crear capa de l√≠mite de alcald√≠a sin relleno y l√≠nea gris oscuro
      limiteAlcaldiaLayer = L.geoJson(data, {
          style: function(feature) {
            return {
              fillOpacity: 0,          // Sin relleno
              color: "#404040",        // Gris oscuro
              weight: 2.5,             // Grosor medio
              opacity: 0.8,
              interactive: false       // Desactivar interacci√≥n (no popup, no click)
            };
          }
      }).addTo(map);

      // Enviar l√≠mite de alcald√≠a al fondo (debajo de todos los dem√°s elementos)
      if (limiteAlcaldiaLayer) {
        limiteAlcaldiaLayer.bringToBack();
        // Asegurar que est√© en el fondo despu√©s de que otras capas se carguen
        setTimeout(() => {
          if (limiteAlcaldiaLayer) limiteAlcaldiaLayer.bringToBack();
        }, 1000);
      }

      console.log("‚úÖ L√≠mite de alcald√≠a cargado como capa base de referencia");
    })
    .catch(err => {
      console.error("‚ùå Error al cargar l√≠mite de alcald√≠a:", err);
      // No mostrar alerta para no interrumpir, solo registrar en consola
      console.log("Nota: El archivo limite_alcaldia.geojson no se encontr√≥ o hay error en su carga");
    });

  // ‚úÖ OPTIMIZACI√ìN: Cargar solicitudes por mes de forma progresiva
  function cargarMes(nombreMes, archivo) {
    return fetch(`archivos/solicitudes/meses separados/${archivo}`)
      .then(res => res.json())
      .then(data => {
        console.log(`üìÖ Cargando ${nombreMes}:`, data.features.length, 'solicitudes');
        solicitudesPorMes[nombreMes].geojson = data;
        solicitudesPorMes[nombreMes].ids = []; // ‚úÖ Guardar IDs para filtrado r√°pido
        
        // Procesar features y agregar a array del mes
        data.features.forEach(f => {
          if (!f.geometry || f.geometry.type !== "Point" || !Array.isArray(f.geometry.coordinates)) return;
          
          const rawCol = f.properties["name"] || f.properties["NOMBRE"] || f.properties["colonia"] || null;
          
          // ‚úÖ Guardar √≠ndice global ANTES de hacer push
          const globalIdx = solicitudes.length;
          
          const tipo = f.properties["Tipo de reporte"] || "Sin tipo";
          const estado = f.properties["Estado Reporte"] || "Sin estado";
          
          const solicitud = {
            "N√∫mero folio": f.properties["N√∫mero folio"],
            "Tipo de reporte": tipo,
            "Estado Reporte": estado,
            "Fecha reporte": f.properties["Fecha reporte"],
            "Nombre Ciudadano": f.properties["Nombre Ciudadano"],
            "Tel√©fono": f.properties["Tel√©fono"],
            "Punto de referencia": f.properties["Punto de referencia"],
            "Coordenada X": f.geometry.coordinates[0],
            "Coordenada Y": f.geometry.coordinates[1],
            "Colonia": rawCol,
            "ColoniaNorm": normalizeKey(rawCol),
            "seccion": f.properties["seccion"] || f.properties["SECCION"],
            "transi": f.properties["transi"] || f.properties["Transi"] || f.properties["TRANSI"],
            "mes": nombreMes, // ‚úÖ Marcar con el mes
            "_globalId": globalIdx // ‚úÖ Guardar ID global para b√∫squeda r√°pida
          };
          
          solicitudesPorMes[nombreMes].solicitudes.push(solicitud);
          solicitudesPorMes[nombreMes].ids.push(globalIdx); // ‚úÖ CRITICAL: Guardar ID
          solicitudes.push(solicitud); // Tambi√©n agregarlo al array general
          
          // ‚úÖ CONSTRUIR √çNDICES MES+TIPO Y MES+ESTADO PARA FILTRADO ULTRA R√ÅPIDO
          const mesTipoKey = `${nombreMes}:${tipo}`;
          const mesEstadoKey = `${nombreMes}:${estado}`;
          
          if (!indiceMesTipo[mesTipoKey]) {
            indiceMesTipo[mesTipoKey] = [];
          }
          indiceMesTipo[mesTipoKey].push(globalIdx);
          
          if (!indiceMesEstado[mesEstadoKey]) {
            indiceMesEstado[mesEstadoKey] = [];
          }
          indiceMesEstado[mesEstadoKey].push(globalIdx);
        });
        
        mesesCargados++;
        console.log(`‚úÖ ${nombreMes} cargado (${mesesCargados}/${totalMeses}) - ${solicitudesPorMes[nombreMes].ids.length} solicitudes`);
        console.log(`   √çndices creados: ${Object.keys(indiceMesTipo).filter(k => k.startsWith(nombreMes)).length} tipos, ${Object.keys(indiceMesEstado).filter(k => k.startsWith(nombreMes)).length} estados`);
        
        // Si todos los meses est√°n cargados, inicializar
        if (mesesCargados === totalMeses) {
          console.log("‚úÖ TODOS LOS MESES CARGADOS:", solicitudes.length, "solicitudes totales");
          console.log("üìä √çNDICES MES+TIPO CREADOS:", Object.keys(indiceMesTipo).length);
          console.log("üìä √çNDICES MES+ESTADO CREADOS:", Object.keys(indiceMesEstado).length);
          
          // Combinar todos los GeoJSON en uno
          solicitudesGeoJSON = {
            type: "FeatureCollection",
            features: []
          };
          Object.values(solicitudesPorMes).forEach(mes => {
            if (mes.geojson && mes.geojson.features) {
              solicitudesGeoJSON.features.push(...mes.geojson.features);
            }
          });
          
          solicitudesLoaded = true;
          iniciarSiTodoEstaListo();
        }
      })
      .catch(err => {
        console.error(`‚ùå Error al cargar ${nombreMes}:`, err);
        mesesCargados++; // Contar como cargado para no bloquear
        if (mesesCargados === totalMeses) {
          solicitudesLoaded = true;
          iniciarSiTodoEstaListo();
        }
      });
  }

  // Cargar todos los meses en paralelo (m√°s r√°pido)
  console.log("üì• Iniciando carga de solicitudes por mes...");
  
  // ‚úÖ PRIMERO: Cargar archivo completo Solicitudes.geojson para incluir TODAS las solicitudes
  fetch("archivos/solicitudes/Solicitudes.geojson")
    .then(res => res.json())
    .then(data => {
      console.log(`üì• Cargadas ${data.features.length} solicitudes del archivo completo`);
      
      // Guardar el GeoJSON completo
      solicitudesGeoJSON = data;
      
      // Procesar features del archivo completo
      data.features.forEach(f => {
        if (!f.geometry || f.geometry.type !== "Point" || !Array.isArray(f.geometry.coordinates)) return;
        
        const rawCol = f.properties["name"] || f.properties["NOMBRE"] || f.properties["colonia"] || null;
        const tipo = f.properties["Tipo de reporte"] || "Sin tipo";
        const estado = f.properties["Estado Reporte"] || "Sin estado";
        
        // Determinar mes de los datos
        let nombreMes = "desconocido";
        if (f.properties["Fecha reporte"]) {
          const fecha = new Date(f.properties["Fecha reporte"]);
          if (!isNaN(fecha)) {
            nombreMes = fecha.toLocaleString('es-ES', { month: 'long' });
          }
        }
        
        // ‚úÖ GUARDAR ID ANTES de hacer push
        const globalIdx = solicitudes.length;
        
        const solicitud = {
          "N√∫mero folio": f.properties["N√∫mero folio"],
          "Tipo de reporte": tipo,
          "Estado Reporte": estado,
          "Fecha reporte": f.properties["Fecha reporte"],
          "Nombre Ciudadano": f.properties["Nombre Ciudadano"],
          "Tel√©fono": f.properties["Tel√©fono"],
          "Punto de referencia": f.properties["Punto de referencia"],
          "Coordenada X": f.geometry.coordinates[0],
          "Coordenada Y": f.geometry.coordinates[1],
          "Colonia": rawCol,
          "ColoniaNorm": normalizeKey(rawCol),
          "seccion": f.properties["seccion"] || f.properties["SECCION"],
          "transi": f.properties["transi"] || f.properties["Transi"] || f.properties["TRANSI"],
          "mes": nombreMes,
          "_globalId": globalIdx,
          "_id": globalIdx
        };
        
        solicitudes.push(solicitud);
        allIds.push(globalIdx);
      });
      
      console.log(`‚úÖ Total de solicitudes cargadas (archivo completo): ${solicitudes.length}`);
      console.log(`   solicitudesGeoJSON establecido: ${solicitudesGeoJSON ? 'S√ç' : 'NO'}`);
      console.log(`   solicitudesGeoJSON.features: ${solicitudesGeoJSON?.features?.length || 0}`);
      solicitudesLoaded = true;
      iniciarSiTodoEstaListo();
    })
    .catch(err => {
      console.warn("‚ö†Ô∏è No se pudo cargar archivo completo, continuando con meses separados:", err);
      // Continuar con los meses separados
      Promise.all([
        cargarMes('junio', 'Mes_junio.geojson'),
        cargarMes('julio', 'Mes_julio.geojson'),
        cargarMes('agosto', 'Mes_agosto.geojson'),
        cargarMes('septiembre', 'Mes_septiembre.geojson'),
        cargarMes('octubre', 'Mes_octubre.geojson'),
        cargarMes('noviembre', 'Mes_noviembre.geojson'),
        cargarMes('diciembre', 'Mes_diciembre.geojson')
      ]).then(() => {
        console.log("üéâ Carga completa de todos los meses");
        solicitudesLoaded = true;
        iniciarSiTodoEstaListo();
      });
    });

  // Cargar todos los meses en paralelo (complemento del archivo completo)
  // Descomentar si hay duplicados y se necesita deduplicaci√≥n
  /*
  Promise.all([
    cargarMes('junio', 'Mes_junio.geojson'),
    cargarMes('julio', 'Mes_julio.geojson'),
    cargarMes('agosto', 'Mes_agosto.geojson'),
    cargarMes('septiembre', 'Mes_septiembre.geojson'),
    cargarMes('octubre', 'Mes_octubre.geojson'),
    cargarMes('noviembre', 'Mes_noviembre.geojson'),
    cargarMes('diciembre', 'Mes_diciembre.geojson')
  ]).then(() => {
    console.log("üéâ Carga completa de todos los meses");
  });
  */

  }

  // ========== EVENT LISTENERS ==========
  let btnAplicarFiltros = document.getElementById("btnAplicarFiltros");
  let btnBuscarGeneral = document.getElementById("btnBuscarGeneral");
  let btnResetBuscar = document.getElementById("btnResetBuscar");
  let selectFiltroTipo = document.getElementById("filtroTipo");
  let selectFiltroEstado = document.getElementById("filtroEstado");
  let selectFiltroMes = document.getElementById("filtroMes");
  
    // ‚úÖ NUEVA OPTIMIZACI√ìN: Debounce para renderizado suave
    renderizarDebounced = debounce(renderizar, 150);
  
  // ‚úÖ Filtros ahora responden solo al bot√≥n "Aplicar filtros"
  
  // Agregar listeners solo una vez
  if (btnAplicarFiltros && !btnAplicarFiltros.hasListener) {
    btnAplicarFiltros.addEventListener("click", () => {
      const tipo = selectFiltroTipo.value;
      const estado = selectFiltroEstado.value;
      const mes = selectFiltroMes.value;
      if (typeof renderizarDebounced === 'function') {
        renderizarDebounced(tipo, estado, mes);
      } else {
        renderizar(tipo, estado, mes);
      }
    });
    btnAplicarFiltros.hasListener = true;
  }

  if (btnBuscarGeneral && !btnBuscarGeneral.hasListener) {
    btnBuscarGeneral.addEventListener("click", () => {
      let valor = document.getElementById("buscadorGeneral").value.trim();
      if (!valor) return;

      let solicitud = solicitudes.find(s => s["N√∫mero folio"] == valor);
      if (solicitud) {
        let lat = parseFloat(solicitud["Coordenada Y"]);
        let lon = parseFloat(solicitud["Coordenada X"]);
        if (!isNaN(lat) && !isNaN(lon)) {
          // Hacer zoom a nivel 17 (suficiente para ver puntos)
          map.setView([lat, lon], 17);
          
          // Crear y mostrar popup con la informaci√≥n del folio
          const popupContent = `
            <div style="max-width: 250px;">
              <b>Folio:</b> ${solicitud["N√∫mero folio"]}<br>
              <b>Ciudadano:</b> ${solicitud["Nombre Ciudadano"] || 'N/A'}<br>
              <b>Tel√©fono:</b> ${solicitud["Tel√©fono"] || 'N/A'}<br>
              <b>Tipo:</b> ${solicitud["Tipo de reporte"]}<br>
              <b>Estado:</b> ${solicitud["Estado Reporte"]}<br>
              <b>Punto de referencia:</b> ${solicitud["Punto de referencia"] || 'N/A'}<br>
              <b>Fecha:</b> ${solicitud["Fecha reporte"] || 'N/A'}
            </div>
          `;
          L.popup()
            .setLatLng([lat, lon])
            .setContent(popupContent)
            .openOn(map);
        }

        let tipo = solicitud["Tipo de reporte"];
        let estado = solicitud["Estado Reporte"];
        document.getElementById("filtroTipo").value = tipo || "Todos";
        document.getElementById("filtroEstado").value = estado || "Todos";
        renderizar(tipo || "Todos", estado || "Todos", "Todos");
        return;
      }
      // Si no es folio, intentar buscar por colonia (normalizando texto)
      const valorNorm = normalizeKey(valor);
      let foundColoniaLayer = null;
      try {
        if (coloniasLayer) {
          coloniasLayer.eachLayer(layer => {
            const name = layer.feature && (layer.feature.properties && (layer.feature.properties.NOMBRE || layer.feature.properties.name));
            const n = normalizeKey(name);
            if (n && valorNorm && n === valorNorm) {
              foundColoniaLayer = layer;
            }
          });
        }
      } catch (e) {
        console.log('Error buscando colonia:', e);
      }

      if (foundColoniaLayer) {
        // Hacer zoom a la colonia
        try {
          const bounds = foundColoniaLayer.getBounds();
          map.fitBounds(bounds);
          // Despu√©s de fitBounds, hacer zoom adicional si es necesario para ver puntos
          setTimeout(() => {
            if (map.getZoom() < 16) map.setZoom(16);
          }, 100);
        } catch (e) {
          console.log("Error en fitBounds:", e);
        }
        
        // Seleccionar colonia y limpiar selecci√≥n de secci√≥n
        seccionSeleccionada = null;
        coloniaSeleccionada = foundColoniaLayer;
        
        if (selectedOutline) {
          map.removeLayer(selectedOutline);
          selectedOutline = null;
        }
        
        selectedOutline = L.geoJSON(foundColoniaLayer.toGeoJSON(), {
          style: { color: "red", weight: 3, fill: false }
        }).addTo(map);
        
        if (selectedOutline.bringToFront) selectedOutline.bringToFront();

        // Renderizar con filtros actuales
        const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
        const estado = document.getElementById('filtroEstado')?.value || 'Todos';
        const mes = document.getElementById('filtroMes')?.value || 'Todos';
        renderizar(tipo, estado, mes);
        return;
      }
      
      // Si no es folio ni colonia, intentar buscar por secci√≥n
      let foundSeccionLayer = null;
      try {
        if (seccionesLayer) {
          const valorKey = normalizeSeccionKey(valor);
          seccionesLayer.eachLayer(layer => {
            const seccion = layer.feature && layer.feature.properties && (layer.feature.properties.seccion || layer.feature.properties.SECCION);
            // Comparar como string (el usuario puede escribir "3260")
            if (seccion && valorKey && normalizeSeccionKey(seccion) === valorKey) {
              foundSeccionLayer = layer;
            }
          });
        }
      } catch (e) {
        console.log('Error buscando secci√≥n:', e);
      }
      
      if (foundSeccionLayer) {
        // Hacer zoom a la secci√≥n
        try {
          const bounds = foundSeccionLayer.getBounds();
          map.fitBounds(bounds);
          setTimeout(() => {
            if (map.getZoom() < 16) map.setZoom(16);
          }, 100);
        } catch (e) {
          console.log("Error en fitBounds:", e);
        }
        
        // Seleccionar secci√≥n y limpiar selecci√≥n de colonia
        coloniaSeleccionada = null;
        seccionSeleccionada = foundSeccionLayer;
        
        const secNum = foundSeccionLayer.feature?.properties?.seccion || foundSeccionLayer.feature?.properties?.SECCION;
        console.log('üéØ SECCI√ìN SELECCIONADA:', secNum);
        console.log('   seccionSeleccionada asignada:', seccionSeleccionada ? 'S√ç' : 'NO');
        
        if (selectedOutline) {
          map.removeLayer(selectedOutline);
          selectedOutline = null;
        }
        
        selectedOutline = L.geoJSON(foundSeccionLayer.toGeoJSON(), {
          style: { color: "red", weight: 3, fill: false }
        }).addTo(map);
        
        if (selectedOutline.bringToFront) selectedOutline.bringToFront();
        
        // Renderizar con filtros actuales
        const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
        const estado = document.getElementById('filtroEstado')?.value || 'Todos';
        const mes = document.getElementById('filtroMes')?.value || 'Todos';
        renderizar(tipo, estado, mes);
        return;
      }

      alert("No se encontr√≥ folio, colonia ni secci√≥n con: " + valor);
    });
    btnBuscarGeneral.hasListener = true;
  }

  // ========== AUTOCOMPLETADO FALLBACK (M√ìVIL Y ESCRITORIO) ==========
  function initializeAutocompleteFallback() {
    // Activar en todos los dispositivos para experiencia uniforme
    try {
      const input = document.getElementById('buscadorGeneral');
      if (!input) return;
      const group = input.closest('.input-group') || document.getElementById('sidebar');
      if (!group) return;

      // Crear contenedor si no existe
      if (!autocompleteContainer) {
        autocompleteContainer = document.createElement('div');
        autocompleteContainer.id = 'autocompleteList';
        autocompleteContainer.className = 'autocomplete-list';
        autocompleteContainer.style.display = 'none';
        group.appendChild(autocompleteContainer);
      }

      const renderSuggestions = (q) => {
        if (!q || q.trim().length < 1) { autocompleteContainer.style.display = 'none'; autocompleteContainer.innerHTML=''; return; }
        const qn = normalizeKey(q);
        const matches = [];
        for (let i = 0; i < coloniasList.length; i++) {
          const name = coloniasList[i];
          const nn = normalizeKey(name);
          if (nn && nn.indexOf(qn) !== -1) {
            matches.push({ name, pos: nn.indexOf(qn) });
          }
          if (matches.length >= 50) break; // l√≠mite razonable
        }
        matches.sort((a,b)=> a.pos - b.pos || a.name.localeCompare(b.name,'es',{sensitivity:'base'}));
        const top = matches.slice(0, 15);
        if (top.length === 0) { autocompleteContainer.style.display = 'none'; autocompleteContainer.innerHTML=''; return; }

        let html = '';
        top.forEach(m => {
          html += `<div class="autocomplete-item" data-value="${m.name.replace(/"/g,'&quot;')}">${m.name}</div>`;
        });
        autocompleteContainer.innerHTML = html;
        autocompleteContainer.style.display = 'block';

        // Click handler por item
        Array.from(autocompleteContainer.children).forEach(el => {
          el.addEventListener('click', () => {
            const val = el.getAttribute('data-value');
            input.value = val || '';
            autocompleteContainer.style.display = 'none';
            // No disparamos b√∫squeda autom√°tica; usuario decide
          }, { once: true });
        });
      };

      // Listeners del input
      input.addEventListener('input', () => renderSuggestions(input.value));
      input.addEventListener('focus', () => {
        if (input.value && input.value.length > 0) renderSuggestions(input.value);
      });
      input.addEventListener('blur', () => {
        // delay m√°s largo para permitir click/touch en la lista (especialmente en m√≥vil)
        setTimeout(() => { if (autocompleteContainer) autocompleteContainer.style.display = 'none'; }, 300);
      });

      // Enter: si hay sugerencias visibles, tomar la primera
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && autocompleteContainer && autocompleteContainer.style.display !== 'none') {
          const first = autocompleteContainer.querySelector('.autocomplete-item');
          if (first) {
            e.preventDefault();
            input.value = first.getAttribute('data-value');
            autocompleteContainer.style.display = 'none';
          }
        }
      });
    } catch (e) {
      console.log('Autocomplete fallback error:', e);
    }
  }

  if (btnResetBuscar && !btnResetBuscar.hasListener) {
    btnResetBuscar.addEventListener("click", () => {
      // Mostrar loading overlay y deshabilitar bot√≥n de inmediato (s√≠ncrono)
      const loadingDiv = document.getElementById('loadingOverlay');
      if (loadingDiv) loadingDiv.style.display = 'flex';
      btnResetBuscar.disabled = true;
      btnResetBuscar.style.opacity = '0.5';
      
      document.getElementById("buscadorGeneral").value = "";
      document.getElementById("filtroTipo").value = "Todos";
      document.getElementById("filtroEstado").value = "Todos";
      document.getElementById("filtroMes").value = "Todos";
      coloniaSeleccionada = null;
      if (selectedOutline) {
        map.removeLayer(selectedOutline);
        selectedOutline = null;
      }
      renderizar("Todos", "Todos", "Todos");
      map.setView([19.35, -99.2], 13);
      // Re-habilitar bot√≥n despu√©s de que termine la carga
      setTimeout(() => {
        btnResetBuscar.disabled = false;
        btnResetBuscar.style.opacity = '1';
      }, 600);
    });
    btnResetBuscar.hasListener = true;
  }

  // ========== TABLA POR TIPO DE SOLICITUD (INVERSA) ==========
  function generarTablaTipos() {
    // Si ya est√° generada, solo reactivar listeners
    if (tablasGeneradas.tipos) {
      adjuntarListenersTipos();
      habilitarSeleccionCeldas();
      return;
    }
    
    // Agrupar solicitudes por tipo - OPTIMIZADO
    const tipos = {};
    const len = solicitudes.length;
    
    for (let i = 0; i < len; i++) {
      const s = solicitudes[i];
      const tipo = s["Tipo de reporte"] || "Sin tipo";
      const tel = s["Tel√©fono"] || "Sin tel√©fono";
      const nombre = s["Nombre Ciudadano"] || "Sin nombre";
      const estado = s["Estado Reporte"] || "Sin estado";
      
      if (!tipos[tipo]) {
        tipos[tipo] = {
          tipo: tipo,
          total: 0,
          atendido: 0,
          pendiente: 0,
          enAtencion: 0,
          noCompete: 0,
          ciudadanos: {}
        };
      }
      
      const tipoObj = tipos[tipo];
      tipoObj.total++;
      
      // Contabilizar por estado - optimizado
      switch(estado) {
        case "Atendido": tipoObj.atendido++; break;
        case "Pendiente": tipoObj.pendiente++; break;
        case "En atenci√≥n": tipoObj.enAtencion++; break;
        case "No compete": tipoObj.noCompete++; break;
      }
      
      // Agrupar por ciudadano dentro del tipo
      const ciudadanoKey = tel + '|' + nombre;
      if (!tipoObj.ciudadanos[ciudadanoKey]) {
        tipoObj.ciudadanos[ciudadanoKey] = {
          telefono: tel,
          nombre: nombre,
          total: 0,
          atendido: 0,
          pendiente: 0,
          enAtencion: 0,
          noCompete: 0
        };
      }
      
      const ciudadanoObj = tipoObj.ciudadanos[ciudadanoKey];
      ciudadanoObj.total++;
      switch(estado) {
        case "Atendido": ciudadanoObj.atendido++; break;
        case "Pendiente": ciudadanoObj.pendiente++; break;
        case "En atenci√≥n": ciudadanoObj.enAtencion++; break;
        case "No compete": ciudadanoObj.noCompete++; break;
      }
    }
    
    // Convertir a array y ordenar por total descendente
    const tiposArray = Object.values(tipos).sort((a, b) => b.total - a.total);
    
    // Generar HTML usando array - M√ÅS R√ÅPIDO
    const htmlParts = [];
    htmlParts.push('<table class="tabla-ciudadanos"><thead><tr>');
    htmlParts.push('<th style="width:40px;"></th>');
    htmlParts.push('<th>Tipo de Solicitud</th>');
    htmlParts.push('<th>Atendido</th>');
    htmlParts.push('<th>Pendiente</th>');
    htmlParts.push('<th>En atenci√≥n</th>');
    htmlParts.push('<th>No compete</th>');
    htmlParts.push('<th>Total</th>');
    htmlParts.push('</tr></thead><tbody>');
    
    tiposArray.forEach((t, idx) => {
      const detailId = 'detail-tipo-' + idx;
      
      // Fila principal
      htmlParts.push(`<tr class="toggle-row" data-target="${detailId}">`);
      htmlParts.push(`<td style="text-align:center;"><span class="toggle-icon">‚ñ∂</span></td>`);
      htmlParts.push(`<td><strong>${t.tipo}</strong></td>`);
      htmlParts.push(`<td style="text-align:center;">${t.atendido}</td>`);
      htmlParts.push(`<td style="text-align:center;">${t.pendiente}</td>`);
      htmlParts.push(`<td style="text-align:center;">${t.enAtencion}</td>`);
      htmlParts.push(`<td style="text-align:center;">${t.noCompete}</td>`);
      htmlParts.push(`<td style="text-align:center; font-weight:bold;">${t.total}</td>`);
      htmlParts.push('</tr>');
      
      // Fila de detalle con ciudadanos
      htmlParts.push(`<tr class="detail-row" id="${detailId}">`);
      htmlParts.push('<td colspan="7"><div class="detail-content">');
      htmlParts.push('<strong>Ciudadanos que reportaron este tipo:</strong>');
      htmlParts.push('<table class="detail-table"><thead><tr>');
      htmlParts.push('<th style="color:#000;">N√∫mero Tel√©fono</th>');
      htmlParts.push('<th style="color:#000;">Nombre</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">Atendido</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">Pendiente</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">En atenci√≥n</th>');
      htmlParts.push('<th style="color:#000;">No compete</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">Total</th>');
      htmlParts.push('</tr></thead><tbody>');
      
      // Ordenar ciudadanos por total descendente
      const ciudadanosOrdenados = Object.values(t.ciudadanos).sort((a, b) => b.total - a.total);
      ciudadanosOrdenados.forEach(c => {
        htmlParts.push(`<tr><td>${c.telefono}</td><td>${c.nombre}</td>`);
        htmlParts.push(`<td style="text-align:center;">${c.atendido}</td>`);
        htmlParts.push(`<td style="text-align:center;">${c.pendiente}</td>`);
        htmlParts.push(`<td style="text-align:center;">${c.enAtencion}</td>`);
        htmlParts.push(`<td style="text-align:center;">${c.noCompete}</td>`);
        htmlParts.push(`<td style="text-align:center; font-weight:bold;">${c.total}</td></tr>`);
      });
      
      htmlParts.push('</tbody></table></div></td></tr>');
    });
    
    htmlParts.push('</tbody></table>');
    
    // Insertar HTML de forma as√≠ncrona para no bloquear el navegador
    requestAnimationFrame(() => {
      document.getElementById('contenidoTablaTipos').innerHTML = htmlParts.join('');
      tablasGeneradas.tipos = true; // Marcar como generada
      requestAnimationFrame(() => {
        adjuntarListenersTipos();
        habilitarSeleccionCeldas();
      });
    });
  }
  
  function adjuntarListenersTipos() {
    // Remover listeners duplicados clonando elementos
    document.querySelectorAll('#contenidoTablaTipos .toggle-icon').forEach(icon => {
      const newIcon = icon.cloneNode(true);
      icon.parentNode.replaceChild(newIcon, icon);
      
      newIcon.style.cursor = 'pointer';
      newIcon.addEventListener('click', function(e) {
        e.stopPropagation();
        const row = this.closest('.toggle-row');
        const targetId = row.getAttribute('data-target');
        const detailRow = document.getElementById(targetId);
        
        if (detailRow.classList.contains('show')) {
          detailRow.classList.remove('show');
          this.textContent = '‚ñ∂';
        } else {
          detailRow.classList.add('show');
          this.textContent = '‚ñº';
          
          // Habilitar selecci√≥n en la tabla de detalle reci√©n expandida
          setTimeout(() => {
            const detailTable = detailRow.querySelector('.detail-table');
            if (detailTable) {
              habilitarSeleccionEnTabla(detailTable);
            }
          }, 50);
        }
      });
    });
    
    // Habilitar selecci√≥n de celdas
    habilitarSeleccionCeldas();
  }

  // ========== TABLA CIUDADANOS ==========
  function generarTablaCiudadanos() {
    // Si ya est√° generada, solo reactivar listeners
    if (tablasGeneradas.ciudadanos) {
      adjuntarListenersCiudadanos();
      habilitarSeleccionCeldas();
      return;
    }
    
    // Agrupar solicitudes por tel√©fono - OPTIMIZADO
    const ciudadanos = {};
    const len = solicitudes.length;
    
    for (let i = 0; i < len; i++) {
      const s = solicitudes[i];
      const tel = s["Tel√©fono"] || "Sin tel√©fono";
      const nombre = s["Nombre Ciudadano"] || "Sin nombre";
      const tipo = s["Tipo de reporte"] || "Sin tipo";
      const estado = s["Estado Reporte"] || "Sin estado";
      
      if (!ciudadanos[tel]) {
        ciudadanos[tel] = {
          telefono: tel,
          nombre: nombre,
          total: 0,
          atendido: 0,
          pendiente: 0,
          enAtencion: 0,
          noCompete: 0,
          tipos: {}
        };
      }
      
      const ciudadanoObj = ciudadanos[tel];
      ciudadanoObj.total++;
      
      // Contabilizar por estado - optimizado con switch
      switch(estado) {
        case "Atendido": ciudadanoObj.atendido++; break;
        case "Pendiente": ciudadanoObj.pendiente++; break;
        case "En atenci√≥n": ciudadanoObj.enAtencion++; break;
        case "No compete": ciudadanoObj.noCompete++; break;
      }
      
      // Contabilizar por tipo y estado
      if (!ciudadanoObj.tipos[tipo]) {
        ciudadanoObj.tipos[tipo] = {
          total: 0,
          atendido: 0,
          pendiente: 0,
          enAtencion: 0,
          noCompete: 0
        };
      }
      const tipoObj = ciudadanoObj.tipos[tipo];
      tipoObj.total++;
      switch(estado) {
        case "Atendido": tipoObj.atendido++; break;
        case "Pendiente": tipoObj.pendiente++; break;
        case "En atenci√≥n": tipoObj.enAtencion++; break;
        case "No compete": tipoObj.noCompete++; break;
      }
    }
    
    // Convertir a array y ordenar por total descendente
    const ciudadanosArray = Object.values(ciudadanos).sort((a, b) => b.total - a.total);
    
    // Generar HTML usando array - M√ÅS R√ÅPIDO
    const htmlParts = [];
    htmlParts.push('<table class="tabla-ciudadanos"><thead><tr>');
    htmlParts.push('<th style="width:40px;"></th>');
    htmlParts.push('<th>N√∫mero Tel√©fono</th>');
    htmlParts.push('<th>Nombre</th>');
    htmlParts.push('<th>Atendido</th>');
    htmlParts.push('<th>Pendiente</th>');
    htmlParts.push('<th>En atenci√≥n</th>');
    htmlParts.push('<th>No compete</th>');
    htmlParts.push('<th>Total</th>');
    htmlParts.push('</tr></thead><tbody>');
    
    ciudadanosArray.forEach((c, idx) => {
      const detailId = 'detail-' + idx;
      
      // Fila principal
      htmlParts.push(`<tr class="toggle-row" data-target="${detailId}">`);
      htmlParts.push(`<td style="text-align:center;"><span class="toggle-icon">‚ñ∂</span></td>`);
      htmlParts.push(`<td>${c.telefono}</td>`);
      htmlParts.push(`<td>${c.nombre}</td>`);
      htmlParts.push(`<td style="text-align:center;">${c.atendido}</td>`);
      htmlParts.push(`<td style="text-align:center;">${c.pendiente}</td>`);
      htmlParts.push(`<td style="text-align:center;">${c.enAtencion}</td>`);
      htmlParts.push(`<td style="text-align:center;">${c.noCompete}</td>`);
      htmlParts.push(`<td style="text-align:center; font-weight:bold;">${c.total}</td>`);
      htmlParts.push('</tr>');
      
      // Fila de detalle
      htmlParts.push(`<tr class="detail-row" id="${detailId}">`);
      htmlParts.push('<td colspan="8"><div class="detail-content">');
      htmlParts.push('<strong>Detalle por tipo de solicitud:</strong>');
      htmlParts.push('<table class="detail-table"><thead><tr>');
      htmlParts.push('<th style="color:#000;">Tipo de Solicitud</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">Atendido</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">Pendiente</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">En atenci√≥n</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">No compete</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">Total</th>');
      htmlParts.push('</tr></thead><tbody>');
      
      // Ordenar tipos por cantidad descendente
      const tiposOrdenados = Object.entries(c.tipos).sort((a, b) => b[1].total - a[1].total);
      tiposOrdenados.forEach(([tipo, info]) => {
        htmlParts.push(`<tr><td>${tipo}</td>`);
        htmlParts.push(`<td style="text-align:center;">${info.atendido}</td>`);
        htmlParts.push(`<td style="text-align:center;">${info.pendiente}</td>`);
        htmlParts.push(`<td style="text-align:center;">${info.enAtencion}</td>`);
        htmlParts.push(`<td style="text-align:center;">${info.noCompete}</td>`);
        htmlParts.push(`<td style="text-align:center; font-weight:bold;">${info.total}</td></tr>`);
      });
      
      htmlParts.push('</tbody></table></div></td></tr>');
    });
    
    htmlParts.push('</tbody></table>');
    
    // Insertar HTML de forma as√≠ncrona para no bloquear el navegador
    requestAnimationFrame(() => {
      document.getElementById('contenidoTablaCiudadanos').innerHTML = htmlParts.join('');
      tablasGeneradas.ciudadanos = true; // Marcar como generada
      requestAnimationFrame(() => {
        adjuntarListenersCiudadanos();
        habilitarSeleccionCeldas();
      });
    });
  }
  
  function adjuntarListenersCiudadanos() {
    // Remover listeners duplicados clonando elementos
    document.querySelectorAll('#contenidoTablaCiudadanos .toggle-icon').forEach(icon => {
      const newIcon = icon.cloneNode(true);
      icon.parentNode.replaceChild(newIcon, icon);
      
      newIcon.style.cursor = 'pointer';
      newIcon.addEventListener('click', function(e) {
        e.stopPropagation();
        const row = this.closest('.toggle-row');
        const targetId = row.getAttribute('data-target');
        const detailRow = document.getElementById(targetId);
        
        if (detailRow.classList.contains('show')) {
          detailRow.classList.remove('show');
          this.textContent = '‚ñ∂';
        } else {
          detailRow.classList.add('show');
          this.textContent = '‚ñº';
          
          // Habilitar selecci√≥n en la tabla de detalle reci√©n expandida
          setTimeout(() => {
            const detailTable = detailRow.querySelector('.detail-table');
            if (detailTable) {
              habilitarSeleccionEnTabla(detailTable);
            }
          }, 50);
        }
      });
    });
    
    // Habilitar selecci√≥n de celdas estilo Excel
    habilitarSeleccionCeldas();
  }
  
  // ========== SELECCI√ìN DE CELDAS ESTILO EXCEL ==========
  let isSelecting = false;
  let selectedCells = new Set();
  
  // Funci√≥n auxiliar para habilitar selecci√≥n en una tabla espec√≠fica
  function habilitarSeleccionEnTabla(table) {
    const cells = table.querySelectorAll('td');
    let isDragging = false;
    let lastSelectedCell = null;
    
    cells.forEach(cell => {
      // Solo habilitar en celdas con n√∫meros
      const text = cell.textContent.trim();
      const parentRow = cell.closest('tr');
      const isToggleRow = parentRow && parentRow.classList.contains('toggle-row');
      const cellIndex = Array.from(cell.parentElement.children).indexOf(cell);
      
      // Excluir primera columna (icono) y columnas de tel√©fono/nombre (√≠ndices 1 y 2 en tabla principal)
      if (isToggleRow && cellIndex <= 2) return;
      if (cellIndex === 0 && cell.querySelector('.toggle-icon')) return;
      
      // Solo procesar si contiene n√∫mero (permitir comas y guiones)
      const testNum = parseFloat(text.replace(/,/g, ''));
      if (isNaN(testNum) && text !== '-') return;
      
      // Evitar duplicar listeners
      if (cell.hasSelectionListener) return;
      
      cell.style.userSelect = 'none';
      cell.style.cursor = 'cell';
      
      // Mouse Down: Iniciar selecci√≥n por drag
      cell.addEventListener('mousedown', function(e) {
        e.preventDefault();
        e.stopPropagation();
        isDragging = true;
        
        if (!e.shiftKey) {
          // Si NO es Shift: limpiar selecci√≥n anterior
          selectedCells.forEach(c => c.classList.remove('selected'));
          selectedCells.clear();
        }
        
        // Seleccionar celda actual
        this.classList.add('selected');
        selectedCells.add(this);
        lastSelectedCell = this;
        calcularEstadisticas();
      });
      
      // Mouse Enter: Extender selecci√≥n durante drag
      cell.addEventListener('mouseenter', function(e) {
        if (isDragging && !e.shiftKey) {
          // En modo drag (sin Shift): seleccionar rango continuo
          this.classList.add('selected');
          selectedCells.add(this);
          calcularEstadisticas();
        }
      });
      
      // Shift+Click: Agregar/remover celda individual
      cell.addEventListener('click', function(e) {
        if (e.shiftKey) {
          e.preventDefault();
          e.stopPropagation();
          
          if (this.classList.contains('selected')) {
            this.classList.remove('selected');
            selectedCells.delete(this);
          } else {
            this.classList.add('selected');
            selectedCells.add(this);
          }
          lastSelectedCell = this;
          calcularEstadisticas();
        }
      });
      
      cell.hasSelectionListener = true;
    });
    
    // Detener drag cuando sueltes el click (a nivel de documento)
    if (!table.hasGlobalDragStop) {
      document.addEventListener('mouseup', function() {
        isDragging = false;
      });
      table.hasGlobalDragStop = true;
    }
  }
  
  function habilitarSeleccionCeldas() {
    const statsBar = document.getElementById('statsBar');
    const tables = document.querySelectorAll('.tabla-ciudadanos, .detail-table');
    
    tables.forEach(table => {
      habilitarSeleccionEnTabla(table);
    });
    
    // ‚úÖ MEJORADO: Evento global para limpiar selecci√≥n al click fuera de tablas
    if (!document.hasGlobalClickOutside) {
      document.addEventListener('click', (e) => {
        const target = e.target;
        
        // Verificar si el click est√° dentro de alguna tabla o stats bar
        const tables = document.querySelectorAll('table');
        let isInTable = false;
        
        for (let table of tables) {
          if (table.contains(target)) {
            isInTable = true;
            break;
          }
        }
        
        const isInStatsBar = target.closest('#statsBar') !== null;
        
        // Si NO est√° en tabla ni en stats bar, limpiar selecci√≥n
        if (!isInTable && !isInStatsBar) {
          selectedCells.forEach(c => c.classList.remove('selected'));
          selectedCells.clear();
          if (statsBar) statsBar.style.display = 'none';
        }
      }, true);  // Usar capture phase para detectar antes
      document.hasGlobalClickOutside = true;
    }
  }
  
  function calcularEstadisticas() {
    const statsBar = document.getElementById('statsBar');
    const statCount = document.getElementById('statCount');
    const statSum = document.getElementById('statSum');
    const statAvg = document.getElementById('statAvg');
    
    if (selectedCells.size === 0) {
      if (statsBar) statsBar.style.display = 'none';
      return;
    }
    
    const valores = [];
    selectedCells.forEach(cell => {
      const text = cell.textContent.trim();
      const num = parseFloat(text.replace(/,/g, ''));
      if (!isNaN(num)) valores.push(num);
    });
    
    if (valores.length === 0) {
      if (statsBar) statsBar.style.display = 'none';
      return;
    }
    
    const count = valores.length;
    const sum = valores.reduce((a, b) => a + b, 0);
    const avg = sum / count;
    
    if (statCount) statCount.textContent = count.toLocaleString('es-MX');
    if (statSum) statSum.textContent = sum.toLocaleString('es-MX');
    if (statAvg) statAvg.textContent = avg.toLocaleString('es-MX', { maximumFractionDigits: 2 });
    if (statsBar) statsBar.style.display = 'block';
  }
  
  // ‚úÖ Agregar atajo de teclado ESC para deseleccionar
  if (!document.hasEscapeKeyListener) {
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const statsBar = document.getElementById('statsBar');
        selectedCells.forEach(c => c.classList.remove('selected'));
        selectedCells.clear();
        if (statsBar) statsBar.style.display = 'none';
      }
    });
    document.hasEscapeKeyListener = true;
  }
  
  // Event listeners para modal ciudadanos
  const btnVerCiudadanos = document.getElementById('btnVerCiudadanos');
  const btnCerrarModal = document.getElementById('btnCerrarModal');
  const modalCiudadanos = document.getElementById('modalCiudadanos');
  
  if (btnVerCiudadanos && !btnVerCiudadanos.hasListener) {
    btnVerCiudadanos.addEventListener('click', () => {
      // Mostrar loading
      showLoading();
      
      // Abrir modal primero
      modalCiudadanos.style.display = 'block';
      
      // Generar la tabla general (pesta√±a activa por defecto)
      setTimeout(() => {
        const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
        const estado = document.getElementById('filtroEstado')?.value || 'Todos';
        const mes = document.getElementById('filtroMes')?.value || 'Todos';
        generarTablaGeneral(tipo, estado, mes);
        hideLoading();
      }, 50);
    });
    btnVerCiudadanos.hasListener = true;
  }
  
  // Event listeners para cambio de pesta√±as
  document.querySelectorAll('.tab-btn').forEach(btn => {
    if (!btn.hasListener) {
      btn.addEventListener('click', function() {
        const targetTab = this.getAttribute('data-tab');
        
        // Actualizar botones
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        // Actualizar contenido
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById(targetTab).classList.add('active');
        
        // Limpiar selecci√≥n al cambiar de pesta√±a
        if (selectedCells) {
          selectedCells.forEach(c => c.classList.remove('selected'));
          selectedCells.clear();
        }
        const statsBar = document.getElementById('statsBar');
        if (statsBar) statsBar.style.display = 'none';
        
        // Generar tabla correspondiente seg√∫n pesta√±a
        showLoading();
        setTimeout(() => {
          if (targetTab === 'tab-general') {
            const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
            const estado = document.getElementById('filtroEstado')?.value || 'Todos';
            const mes = document.getElementById('filtroMes')?.value || 'Todos';
            generarTablaGeneral(tipo, estado, mes);
          } else if (targetTab === 'tab-ciudadanos') {
            generarTablaCiudadanos();
          } else if (targetTab === 'tab-tipos') {
            generarTablaTipos();
          } else if (targetTab === 'tab-dinamica') {
            // No generar autom√°ticamente, esperar que usuario configure y haga clic en el bot√≥n
            document.getElementById('contenidoTablaDinamica').innerHTML = '<p style="text-align:center; color:#666; padding:40px;">Configure las opciones y haga clic en "Generar Tabla"</p>';
          }
          hideLoading();
        }, 50);
        
        // Re-habilitar selecci√≥n en la nueva tabla
        setTimeout(() => habilitarSeleccionCeldas(), 50);
      });
      btn.hasListener = true;
    }
  });
  
  // Event listener para bot√≥n generar tabla din√°mica
  const btnGenerarDinamica = document.getElementById('btnGenerarDinamica');
  if (btnGenerarDinamica && !btnGenerarDinamica.hasListener) {
    btnGenerarDinamica.addEventListener('click', () => {
      showLoading();
      setTimeout(() => {
        generarTablaDinamica();
        hideLoading();
      }, 50);
    });
    btnGenerarDinamica.hasListener = true;
  }
  
  if (btnCerrarModal && !btnCerrarModal.hasListener) {
    btnCerrarModal.addEventListener('click', () => {
      modalCiudadanos.style.display = 'none';
      // Limpiar selecci√≥n y ocultar barra de estad√≠sticas
      if (selectedCells) {
        selectedCells.forEach(c => c.classList.remove('selected'));
        selectedCells.clear();
      }
      const statsBar = document.getElementById('statsBar');
      if (statsBar) statsBar.style.display = 'none';
      
      // Resetear a primera pesta√±a
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      document.querySelector('.tab-btn[data-tab="tab-ciudadanos"]').classList.add('active');
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      document.getElementById('tab-ciudadanos').classList.add('active');
    });
    btnCerrarModal.hasListener = true;
  }
  
  // Cerrar modal al hacer clic fuera del contenido
  if (modalCiudadanos && !modalCiudadanos.hasListener) {
    modalCiudadanos.addEventListener('click', (e) => {
      if (e.target === modalCiudadanos) {
        modalCiudadanos.style.display = 'none';
      }
    });
    modalCiudadanos.hasListener = true;
  }

  // Toggle Sidebar
  let sidebarToggleTab = document.getElementById("sidebarToggleTab");
  if (sidebarToggleTab && !sidebarToggleTab.hasListener) {
    let sidebarIsHidden = false; // Estado interno del toggle
    const sidebarWidth = 700; // ancho del sidebar en px (debe coincidir con CSS)
    const tabHeight = 40;
    
    // Funci√≥n para actualizar el estado visual del sidebar y la pesta√±a
    function updateSidebarState() {
      const sidebar = document.getElementById('sidebar');
      const tab = document.getElementById('sidebarToggleTab');
      if (!sidebar || !tab) return;
      
      if (sidebarIsHidden) {
        // Ocultar: establecer width a 36px (solo la pesta√±a visible) y transform
        sidebar.style.width = '36px';
        sidebar.style.padding = '0';
        sidebar.style.overflow = 'visible';
        tab.style.position = 'fixed';
        tab.style.left = '0px';
        tab.style.top = '70px';
        tab.style.width = '36px';
        tab.textContent = '‚ò∞';
        console.log('Sidebar ocultado');
      } else {
        // Mostrar: restaurar ancho original
        sidebar.style.width = sidebarWidth + 'px';
        sidebar.style.padding = '10px';
        sidebar.style.overflow = 'auto';
        tab.style.position = 'fixed';
        tab.style.left = (sidebarWidth - 36) + 'px';
        tab.style.top = '70px';
        tab.style.width = '36px';
        tab.textContent = '‚ò∞';
        console.log('Sidebar visible');
      }
    }

    // Event listener del toggle
    sidebarToggleTab.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      sidebarIsHidden = !sidebarIsHidden;
      console.log('Toggle clicked. Sidebar ahora oculto:', sidebarIsHidden);
      updateSidebarState();
      
      // Actualizar mapa tras transici√≥n
      setTimeout(() => {
        if (map && map.invalidateSize) {
          map.invalidateSize();
        }
      }, 350);
    });

    // Reposicionar en resize
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(updateSidebarState, 100);
    });
    
    sidebarToggleTab.hasListener = true;
    // Inicializar al cargar
    setTimeout(updateSidebarState, 100);
  }

  // ========== CONTROLES MAPA: LEYENDA Y TOGGLE PUNTOS ==========
  function createMapControls() {
    // Leyenda antigua - OCULTA (ahora se usa el panel de capas con simbolog√≠a)
    if (!legendControl) {
      legendControl = L.control({ position: 'topright' });
      legendControl.onAdd = function(map) {
        var div = L.DomUtil.create('div', 'info legend');
        div.id = 'mapLegend';
        div.style.background = 'white';
        div.style.padding = '6px';
        div.style.boxShadow = '0 0 6px rgba(0,0,0,0.3)';
        div.style.display = 'none'; // OCULTAR - Ahora usamos panel de capas
        div.innerHTML = '<b>Solicitudes</b><br>Cargando...';
        L.DomEvent.disableClickPropagation(div);
        return div;
      };
      legendControl.addTo(map);
    }

    // Toggle puntos (icono estilo "ojo")
    if (!puntosToggleControl) {
      puntosToggleControl = L.control({ position: 'topright' });
      puntosToggleControl.onAdd = function(map) {
        var div = L.DomUtil.create('div', 'info toggle');
        div.style.background = 'white';
        div.style.padding = '4px';
        div.style.marginTop = '6px';
        div.style.boxShadow = '0 0 6px rgba(0,0,0,0.15)';
        var btn = document.createElement('button');
        btn.id = 'btnTogglePuntos';
        btn.title = 'Mostrar / Ocultar puntos';
        btn.style.border = 'none';
        btn.style.background = 'transparent';
        btn.style.cursor = 'pointer';
        btn.style.fontSize = '18px';
        btn.style.lineHeight = '1';
        btn.innerHTML = 'üëÅÔ∏è';
        btn.style.opacity = showPuntos ? '1' : '0.4';
        div.appendChild(btn);
        L.DomEvent.disableClickPropagation(div);

        btn.addEventListener('click', function() {
          showPuntos = !showPuntos;
          
          if (showPuntos) {
            // üî¥ LAZY LOAD: Si es la PRIMERA VEZ que hace click en el ojo
            if (!puntosYaCargados) {
              console.log('‚è≥ CARGANDO MARCADORES POR PRIMERA VEZ (puede tardar un momento)...');
              showLoading('Cargando marcadores...');
              
              // Renderizar en async para no bloquear UI
              setTimeout(() => {
                try {
                  puntosYaCargados = true;
                  // Obtener filtros actuales
                  const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
                  const estado = document.getElementById('filtroEstado')?.value || 'Todos';
                  const mes = document.getElementById('filtroMes')?.value || 'Todos';
                  
                  // Llamar renderizar para procesar los puntos
                  renderizar(tipo, estado, mes);
                  console.log('‚úÖ Marcadores cargados exitosamente');
                  btn.style.opacity = '1';
                } catch (e) {
                  console.error('‚ùå Error cargando marcadores:', e);
                  puntosYaCargados = false;
                } finally {
                  hideLoading();
                }
              }, 200);
            } else {
              // Ya fueron cargados una vez, solo mostrar/ocultar
              if (puntosLayer && !map.hasLayer(puntosLayer)) {
                map.addLayer(puntosLayer);
              }
              btn.style.opacity = '1';
            }
          } else {
            // Ocultar marcadores
            if (map.hasLayer(puntosLayer)) {
              map.removeLayer(puntosLayer);
            }
            btn.style.opacity = '0.4';
          }
        });

        return div;
      };
      puntosToggleControl.addTo(map);
    }
  }

  function updateLegend(breaks) {
    var div = document.getElementById('mapLegend');
    if (!div) return;
    if (!breaks || breaks.length === 0) {
      div.innerHTML = '<b>Solicitudes</b><br>No hay datos';
      return;
    }
    var html = '<b>Solicitudes</b><br>';
    for (var i = 0; i < breaks.length; i++) {
      var min = (i === 0) ? 1 : (breaks[i - 1] + 1);
      var max = breaks[i];
      var color = classColor(i);
      html += '<div style="display:flex;align-items:center;margin-bottom:4px"><span style="width:16px;height:12px;background:' + color + ';display:inline-block;margin-right:6px;border:1px solid #555"></span><span>' + min + ' - ' + max + '</span></div>';
    }
    // Agregar vialidades al final
    html += '<div style="margin-top:8px;border-top:1px solid #ddd;padding-top:6px">';
    html += '<div style="display:flex;align-items:center;margin-bottom:4px"><span style="width:16px;height:12px;background:#2563EB;opacity:0.6;border:1px solid #1E40AF;display:inline-block;margin-right:6px;"></span><span>Vialidades Primarias</span></div>';
    html += '</div>';
    div.innerHTML = html;
  }

  // Mostrar aviso de rotaci√≥n SOLO en dispositivos m√≥viles / pantallas estrechas y en orientaci√≥n vertical
  function checkOrientation() {
    const rotateDiv = document.getElementById('rotateMessage');
    if (!rotateDiv) return;
    
    // Detectar si es realmente un m√≥vil (no solo pantalla peque√±a)
    const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isMobileWidth = window.innerWidth <= 768;
    
    // Mostrar SOLO si es dispositivo m√≥vil Y est√° en vertical
    if (isMobileDevice && isMobileWidth && window.innerHeight > window.innerWidth) {
      rotateDiv.style.display = 'flex';
    } else {
      rotateDiv.style.display = 'none';
    }
    // Reposicionar la pesta√±a toggle si existe
    try { if (typeof positionToggleTab === 'function') positionToggleTab(); } catch(e){}
    
    // IMPORTANTE: Recalcular isMobile y refreshar mapa al cambiar orientaci√≥n
    const wasTablet = isMobile;
    isMobile = window.innerWidth <= 768;
    
    if (wasTablet !== isMobile) {
      console.log('üì± Orientaci√≥n cambiada. isMobile ahora:', isMobile);
      // Refrescar el mapa para que se ajuste correctamente
      if (map && map.invalidateSize) {
        setTimeout(() => {
          map.invalidateSize();
          console.log('‚úÖ Mapa redimensionado');
        }, 100);
      }
      // Redrawing charts con nuevo tama√±o
      if (chartTipos) chartTipos.resize();
      if (chartColonias) chartColonias.resize();
      if (chartEstados) chartEstados.resize();
      // Re-inicializar autocompletado si es necesario
      try { if (typeof initializeAutocompleteFallback === 'function') initializeAutocompleteFallback(); } catch(e){}
    }
  }
  
  // Ejecutar al cargar para ocultar inmediatamente en PC
  checkOrientation();
  
  window.addEventListener('resize', checkOrientation);
  window.addEventListener('orientationchange', checkOrientation);

  // Service Worker
  if ('serviceWorker' in navigator && !isIOS) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js')
        .then(reg => console.log('‚úÖ Service Worker registrado:', reg.scope))
        .catch(err => console.log('‚ùå Error registrando Service Worker:', err));
    });
  } else if (isIOS) {
    console.log('‚ÑπÔ∏è Service Worker deshabilitado en iOS para evitar recargas/bloqueos');
  }

</script>

<!-- Chatbot IA -->
<button id="chatbotToggleBtn" onclick="toggleChatbot()">ü§ñ Asistente IA</button>

<div id="chatbotContainer">
  <div id="chatbotHeader">
    <h4><span>ü§ñ</span> Asistente IA</h4>
    <div class="controls">
      <button onclick="event.stopPropagation(); openApiKeyConfig();" title="Informaci√≥n">‚ÑπÔ∏è Info</button>
      <button onclick="event.stopPropagation(); toggleChatbot();" title="Cerrar">‚úï</button>
    </div>
  </div>
  
  <div id="apiKeyConfig" style="display:none; padding:15px; background:#e3f2fd; border-bottom:2px solid #2196f3;">
    <p style="margin:0; color:#1976d2; font-size:13px;">
      <strong>‚ÑπÔ∏è Asistente inteligente local</strong><br>
      Este asistente analiza directamente los datos de solicitudes sin necesidad de servicios externos.
      No requiere configuraci√≥n adicional. ¬°Simplemente haz tus preguntas!
      <br><br>
      <button onclick="openApiKeyConfig();" style="background:#922B21; color:white; border:none; padding:6px 12px; border-radius:4px; cursor:pointer;">Cerrar</button>
    </p>
  </div>
  
  <div id="chatbotMessages"></div>
  
  <div id="chatbotInput">
    <input type="text" id="chatInput" placeholder="Pregunta sobre las solicitudes..." onkeypress="if(event.key==='Enter') sendMessage()">
    <button onclick="sendMessage()" id="sendBtn">Enviar</button>
  </div>
</div>

<script>
// ========== CHATBOT IA CON GR√ÅFICAS ==========
let chatHistory = [];
let isProcessing = false;
let contadorGraficas = 0;

function toggleChatbot() {
  const container = document.getElementById('chatbotContainer');
  
  if (!container) {
    console.error('Chatbot container no encontrado');
    return;
  }
  
  container.classList.toggle('open');
  
  // Mostrar mensaje de bienvenida solo la primera vez que se abre
  if (container.classList.contains('open') && chatHistory.length === 0) {
    setTimeout(() => {
      addMessage('system', '¬°Hola! ü§ñ Soy tu asistente de an√°lisis de datos.\n\nPuedo ayudarte con:\n‚Ä¢ **Consultas sobre solicitudes** (pendientes, atendidas, por tipo, colonia, secci√≥n, mes)\n‚Ä¢ **Top N an√°lisis**: "Top 5 colonias con m√°s baches pendientes", "Top 10 secciones"\n‚Ä¢ **Filtros combinados**: "luminarias pendientes de octubre en Barrio Norte"\n‚Ä¢ **Generar gr√°ficas**: "gr√°fica de solicitudes por estado", "gr√°fica de secciones"\n‚Ä¢ **Tablas detalladas**: "tabla de solicitudes por colonia"\n\n¬øEn qu√© puedo ayudarte?');
    }, 300);
  }
}

function openApiKeyConfig() {
  const config = document.getElementById('apiKeyConfig');
  config.style.display = config.style.display === 'none' ? 'block' : 'none';
}

function addMessage(type, content) {
  const messagesDiv = document.getElementById('chatbotMessages');
  if (!messagesDiv) {
    console.error('No se encontr√≥ chatbotMessages');
    return;
  }
  const msgDiv = document.createElement('div');
  msgDiv.className = `chat-message ${type}`;
  
  // Convertir formato markdown simple a HTML
  let htmlContent = content
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/\n/g, '<br>');
  
  msgDiv.innerHTML = htmlContent;
  messagesDiv.appendChild(msgDiv);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function showTyping() {
  const messagesDiv = document.getElementById('chatbotMessages');
  const typingDiv = document.createElement('div');
  typingDiv.id = 'typingIndicator';
  typingDiv.className = 'chat-message assistant typing-indicator';
  typingDiv.innerHTML = '<span></span><span></span><span></span>';
  messagesDiv.appendChild(typingDiv);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function hideTyping() {
  const typing = document.getElementById('typingIndicator');
  if (typing) typing.remove();
}

async function sendMessage() {
  const input = document.getElementById('chatInput');
  const message = input.value.trim();
  
  if (!message || isProcessing) return;
  
  addMessage('user', message);
  input.value = '';
  input.disabled = true;
  document.getElementById('sendBtn').disabled = true;
  isProcessing = true;
  showTyping();
  
  try {
    // Analizar pregunta y generar respuesta LOCAL (sin API externa)
    const response = analyzeLocalData(message);
    
    // Simular delay de procesamiento
    await new Promise(resolve => setTimeout(resolve, 500));
    
    hideTyping();
    addMessage('assistant', response);
    
    chatHistory.push({ role: 'user', content: message });
    chatHistory.push({ role: 'assistant', content: response });
    
    if (chatHistory.length > 10) {
      chatHistory = chatHistory.slice(-10);
    }
    
  } catch (error) {
    hideTyping();
    addMessage('system', `‚ùå Error al procesar: ${error.message}`);
    console.error('Error en chatbot:', error);
  } finally {
    input.disabled = false;
    document.getElementById('sendBtn').disabled = false;
    isProcessing = false;
    input.focus();
  }
}

// Analizar datos localmente sin necesidad de API externa
function analyzeLocalData(query) {
  // Verificar que los datos est√©n cargados
  if (!solicitudes || solicitudes.length === 0) {
    return '‚è≥ Los datos a√∫n se est√°n cargando. Por favor espera unos segundos e intenta de nuevo.';
  }
  
  const lowerQuery = query.toLowerCase();
  
  // Detectar si se solicita una tabla (PRIMERO)
  const requiereTabla = lowerQuery.includes('tabla') || lowerQuery.includes('table') ||
                        lowerQuery.includes('lista detallada') || lowerQuery.includes('desglose');
  
  // Detectar si se solicita una gr√°fica
  const requiereGrafica = !requiereTabla && (lowerQuery.includes('gr√°fica') || lowerQuery.includes('grafica') || 
                          lowerQuery.includes('gr√°fico') || lowerQuery.includes('grafico') || 
                          lowerQuery.includes('visualiza') || lowerQuery.includes('muestra gr√°fico') ||
                          lowerQuery.includes('chart'));
  
  // Extraer filtros de la consulta
  const filtros = extraerFiltros(lowerQuery);
  
  // Aplicar filtros
  let datosFiltrados = [...solicitudes];
  let descripcionFiltros = [];
  
  if (filtros.tipo) {
    datosFiltrados = datosFiltrados.filter(s => {
      const tipo = (s['Tipo de reporte'] || '').toLowerCase();
      return tipo.includes(filtros.tipo);
    });
    descripcionFiltros.push(`tipo "${filtros.tipo}"`);
  }
  
  if (filtros.estado) {
    datosFiltrados = datosFiltrados.filter(s => {
      const estado = (s['Estado Reporte'] || '').toLowerCase();
      return estado.includes(filtros.estado);
    });
    descripcionFiltros.push(`estado "${filtros.estado}"`);
  }
  
  if (filtros.mes) {
    datosFiltrados = datosFiltrados.filter(s => {
      if (!s['Fecha reporte']) return false;
      const fecha = new Date(s['Fecha reporte']);
      const mes = fecha.toLocaleString('es-ES', { month: 'long' }).toLowerCase();
      return mes.includes(filtros.mes);
    });
    descripcionFiltros.push(`mes "${filtros.mes}"`);
  }
  
  if (filtros.colonia) {
    datosFiltrados = datosFiltrados.filter(s => {
      // ‚úÖ MEJORADO: Buscar en m√∫ltiples campos y normalizar espacios
      // Buscar en: name, Colonia, colonia
      const coloniaValue = (s.name || s.Colonia || s.colonia || '').toLowerCase().trim();
      
      // Normalizar: eliminar espacios extra y convertir a min√∫sculas
      const filtroNormalizado = filtros.colonia.trim().toLowerCase();
      
      // Buscar: match exacto o contiene (para "barrio norte" dentro de "barrio norte" o "BARRIO NORTE")
      return coloniaValue.includes(filtroNormalizado) || 
             filtroNormalizado.split(/\s+/).every(palabra => coloniaValue.includes(palabra));
    });
    descripcionFiltros.push(`colonia "${filtros.colonia}"`);
  }
  
  // ‚úÖ NUEVO: Filtrar por secci√≥n (transi)
  if (filtros.seccion) {
    datosFiltrados = datosFiltrados.filter(s => {
      const seccion = (s.transi || s.Transi || s.TRANSI || '').toUpperCase();
      return seccion === filtros.seccion;
    });
    descripcionFiltros.push(`secci√≥n "${filtros.seccion}"`);
  }
  
  // Generar respuesta seg√∫n el tipo de an√°lisis solicitado
  // IMPORTANTE: Verificar primero gr√°ficas y tablas antes que filtros simples
  if (requiereTabla) {
    return generarRespuestaConTabla(lowerQuery, datosFiltrados, descripcionFiltros);
  } else if (requiereGrafica) {
    return generarRespuestaConGrafica(lowerQuery, datosFiltrados, descripcionFiltros);
  } else if (descripcionFiltros.length > 0) {
    // Consulta con filtros espec√≠ficos - SIEMPRE usar esta ruta cuando hay filtros
    return generarRespuestaFiltrada(datosFiltrados, descripcionFiltros, lowerQuery);
  } else {
    // Consultas generales sin filtros
    return generarRespuestaGeneral(lowerQuery, datosFiltrados);
  }
}

function extraerFiltros(query) {
  const filtros = {};
  
  // Extraer tipo de reporte - ‚úÖ MEJORADO: Usar l√≠mites de palabra
  const tiposMap = {
    'bache': ['bache', 'bacheo'],
    'luminaria': ['luminaria', 'luz', 'alumbrado'],
    'poda': ['poda', '√°rbol', 'arbol'],
    'fuga': ['fuga', 'agua'],
    'basura': ['basura', 'residuo'],
    'drenaje': ['drenaje', 'alcantarilla', 'coladera']
  };
  
  for (let [tipoNormalizado, variantes] of Object.entries(tiposMap)) {
    const encontrado = variantes.some(v => {
      const regexVariante = new RegExp(`\\b${v}\\b`, 'i');
      return regexVariante.test(query);
    });
    if (encontrado) {
      filtros.tipo = tipoNormalizado;
      break;
    }
  }
  
  // Extraer estado - IMPORTANTE: solo si aparece como filtro, no como palabra general
  // ‚úÖ MEJORADO: Usar l√≠mites de palabra para estado tambi√©n
  const regexPendiente = new RegExp(`\\bpendiente\\b`, 'i');
  const regexAtendid = new RegExp(`\\batendid`, 'i');
  const regexResuel = new RegExp(`\\bresuel`, 'i');
  const regexEnAtencion = /en\s+atenci√≥n|en\s+atencion/i;
  
  if (regexPendiente.test(query) && !query.includes('solicitudes pendiente de') && !query.includes('pendientes de')) {
    filtros.estado = 'pendiente';
  } else if (regexAtendid.test(query) || regexResuel.test(query)) {
    filtros.estado = 'atendid';
  } else if (regexEnAtencion.test(query)) {
    filtros.estado = 'en atenci√≥n';
  }
  
  // Extraer mes - ‚úÖ MEJORADO: Buscar palabra completa, no dentro de otras palabras
  const meses = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'];
  for (let mes of meses) {
    // Usar regex con l√≠mites de palabra para evitar detectar "mayo" en "mayor"
    const regexMes = new RegExp(`\\b${mes}\\b`, 'i');
    if (regexMes.test(query)) {
      filtros.mes = mes;
      break;
    }
  }
  
  // Extraer colonia - ‚úÖ MEJORADO: Capturar m√∫ltiples palabras (ej: "barrio norte")
  // Buscar todo lo que viene despu√©s de "colonia" hasta la siguiente palabra clave o fin de texto
  let matchColonia = query.match(/colonia\s+(.+?)(?:\s+(?:pendiente|atendid|tipo|estado|secci√≥n|seccion|luz|alumbrado|bache|baches|poda|fuga|basura|drenaje)|\s*$)/i);
  if (matchColonia && matchColonia[1]) {
    filtros.colonia = matchColonia[1].trim().toLowerCase();
  } else {
    // ‚úÖ ALTERNATIVA: Si no dice "colonia", buscar "en [nombre]" o "en la [nombre]"
    // Esto cubre: "en barrio norte", "en la colonia barrio norte"
    matchColonia = query.match(/\ben\s+(?:la\s+(?:colonia\s+)?)?(.+?)(?:\s+(?:pendiente|atendid|tipo|estado|secci√≥n|seccion|luz|alumbrado|bache|baches|poda|fuga|basura|drenaje)|\s*$)/i);
    if (matchColonia && matchColonia[1]) {
      filtros.colonia = matchColonia[1].trim().toLowerCase();
    }
  }
  
  // ‚úÖ NUEVO: Extraer secci√≥n (transi / tipo de secci√≥n)
  const matchSeccion = query.match(/secci√≥n\s+([a-zA-Z0-9]+)|seccion\s+([a-zA-Z0-9]+)|tipo de secci√≥n\s+([a-zA-Z0-9]+)/i);
  if (matchSeccion) {
    filtros.seccion = (matchSeccion[1] || matchSeccion[2] || matchSeccion[3]).toUpperCase();
  } else {
    // ‚úÖ MEJORADO: Detectar por c√≥digo de secci√≥n con l√≠mites de palabra
    const codigosSecciones = ['aa', 'ab', 'ba', 'bb', 'ca', 'cc', 'dd'];
    for (let codigo of codigosSecciones) {
      const regexCodigo = new RegExp(`\\b${codigo}\\b`, 'i');
      if (regexCodigo.test(query)) {
        filtros.seccion = codigo.toUpperCase();
        break;
      }
    }
  }
  
  return filtros;
}

function generarRespuestaFiltrada(datos, descripcionFiltros, query) {
  if (datos.length === 0) {
    return `‚ùå No se encontraron solicitudes con los filtros: ${descripcionFiltros.join(', ')}.`;
  }
  
  // Si solo hay UN filtro de tipo o estado, dar respuesta directa
  if (descripcionFiltros.length === 1) {
    let respuesta = `üîç **Encontr√© ${datos.length.toLocaleString('es-MX')} solicitudes** con ${descripcionFiltros[0]}.\n\n`;
    
    // Desglose adicional
    if (descripcionFiltros[0].includes('tipo')) {
      const porEstado = {};
      datos.forEach(s => {
        const estado = s['Estado Reporte'] || 'Sin estado';
        porEstado[estado] = (porEstado[estado] || 0) + 1;
      });
      respuesta += '**Por estado:**\n';
      Object.keys(porEstado).sort((a,b) => porEstado[b] - porEstado[a]).forEach(estado => {
        respuesta += `‚Ä¢ ${estado}: ${porEstado[estado].toLocaleString('es-MX')}\n`;
      });
    }
    
    return respuesta;
  }
  
  // Para m√∫ltiples filtros, dar respuesta clara y directa
  let respuesta = `üîç **Resultado:** ${datos.length.toLocaleString('es-MX')} solicitudes\n\n`;
  respuesta += `**Filtros aplicados:**\n`;
  descripcionFiltros.forEach(f => {
    respuesta += `‚Ä¢ ${f}\n`;
  });
  
  // Si la pregunta es sobre cantidad, no agregar desglose
  if (query.includes('cu√°ntos') || query.includes('cuantos') || query.includes('cantidad')) {
    return respuesta;
  }
  
  // Agregar desglose por estado solo si no es un filtro de estado
  if (!descripcionFiltros.some(f => f.includes('estado'))) {
    const porEstado = {};
    datos.forEach(s => {
      const estado = s['Estado Reporte'] || 'Sin estado';
      porEstado[estado] = (porEstado[estado] || 0) + 1;
    });
    
    respuesta += '\n**Desglose por estado:**\n';
    Object.keys(porEstado).sort((a,b) => porEstado[b] - porEstado[a]).forEach(estado => {
      respuesta += `‚Ä¢ ${estado}: ${porEstado[estado].toLocaleString('es-MX')}\n`;
    });
  }
  
  return respuesta;
}

function generarRespuestaGeneral(query, datos) {
  // An√°lisis 1: Total de solicitudes
  if (query.includes('cu√°ntas') || query.includes('cuantas') || (query.includes('total') && !query.includes('colonia'))) {
    return `üìä **Total de solicitudes**: ${datos.length.toLocaleString('es-MX')} solicitudes registradas.`;
  }
  
  // An√°lisis 2: Por estado
  if (query.includes('estado')) {
    const porEstado = {};
    datos.forEach(s => {
      const estado = s['Estado Reporte'] || 'Sin estado';
      porEstado[estado] = (porEstado[estado] || 0) + 1;
    });
    
    let respuesta = 'üìã **Solicitudes por estado**:\n\n';
    Object.keys(porEstado).sort((a,b) => porEstado[b] - porEstado[a]).forEach(estado => {
      respuesta += `‚Ä¢ ${estado}: ${porEstado[estado].toLocaleString('es-MX')}\n`;
    });
    return respuesta;
  }
  
  // An√°lisis 3: Por tipo de reporte
  if (query.includes('tipo') || query.includes('reporte')) {
    const porTipo = {};
    datos.forEach(s => {
      const tipo = s['Tipo de reporte'] || 'Sin tipo';
      porTipo[tipo] = (porTipo[tipo] || 0) + 1;
    });
    
    let respuesta = 'üìù **Top 10 tipos de reporte**:\n\n';
    Object.keys(porTipo)
      .sort((a,b) => porTipo[b] - porTipo[a])
      .slice(0, 10)
      .forEach((tipo, i) => {
        respuesta += `${i+1}. ${tipo}: ${porTipo[tipo].toLocaleString('es-MX')}\n`;
      });
    return respuesta;
  }
  
  // An√°lisis 4: Por colonia
  if (query.includes('colonia')) {
    const porColonia = {};
    datos.forEach(s => {
      const colonia = (s.name || s.Colonia || s.colonia || 'Sin colonia').trim();
      porColonia[colonia] = (porColonia[colonia] || 0) + 1;
    });
    
    let respuesta = 'üèòÔ∏è **Top 10 colonias con m√°s solicitudes**:\n\n';
    Object.keys(porColonia)
      .sort((a,b) => porColonia[b] - porColonia[a])
      .slice(0, 10)
      .forEach((colonia, i) => {
        respuesta += `${i+1}. ${colonia}: ${porColonia[colonia].toLocaleString('es-MX')}\n`;
      });
    return respuesta;
  }
  
  // ‚úÖ NUEVO: An√°lisis 4.5: Por secci√≥n (transi)
  if (query.includes('secci√≥n') || query.includes('seccion') || query.includes('tipo de secci√≥n')) {
    const porSeccion = {};
    datos.forEach(s => {
      const seccion = s.transi || s.Transi || s.TRANSI || 'Sin secci√≥n';
      porSeccion[seccion] = (porSeccion[seccion] || 0) + 1;
    });
    
    let respuesta = 'üìç **Solicitudes por secci√≥n (Tipo de Secci√≥n)**:\n\n';
    Object.keys(porSeccion)
      .sort((a,b) => porSeccion[b] - porSeccion[a])
      .forEach((seccion) => {
        respuesta += `‚Ä¢ ${seccion}: ${porSeccion[seccion].toLocaleString('es-MX')}\n`;
      });
    return respuesta;
  }
  
  // An√°lisis 5: Por mes
  if (query.includes('mes') || query.includes('fecha')) {
    const porMes = {};
    datos.forEach(s => {
      if (s['Fecha reporte']) {
        const fecha = new Date(s['Fecha reporte']);
        const mes = fecha.toLocaleString('es-ES', { month: 'long', year: 'numeric' });
        porMes[mes] = (porMes[mes] || 0) + 1;
      }
    });
    
    let respuesta = 'üìÖ **Solicitudes por mes**:\n\n';
    Object.keys(porMes).forEach(mes => {
      respuesta += `‚Ä¢ ${mes}: ${porMes[mes].toLocaleString('es-MX')}\n`;
    });
    return respuesta;
  }
  
  // Si no se reconoce la consulta
  return `‚ùì No entend√≠ tu pregunta. Puedes preguntar sobre:

‚Ä¢ **Total de solicitudes** y por **estado** (pendiente, atendido)
‚Ä¢ **Tipos de reporte** (baches, luminarias, poda, etc.)
‚Ä¢ **Colonias**: "Top 5 colonias con m√°s baches"
‚Ä¢ **Secciones**: "Top 10 secciones", "tabla de secciones"
‚Ä¢ **Meses**: "solicitudes por mes"
‚Ä¢ **Filtros combinados**: "luminarias pendientes de octubre en Barrio Norte"
‚Ä¢ **Gr√°ficas**: "gr√°fica de solicitudes por estado", "gr√°fica de secciones"
‚Ä¢ **Tablas**: "tabla de colonias", "tabla de secciones"

¬øQu√© informaci√≥n necesitas?`;
}

function generarRespuestaConGrafica(query, datos, descripcionFiltros) {
  if (datos.length === 0) {
    return `‚ùå No hay datos para generar la gr√°fica.`;
  }
  
  let textoRespuesta = '';
  let tipoGrafica = 'bar';
  let labels = [];
  let valores = [];
  let titulo = '';
  
  // Determinar qu√© tipo de gr√°fica generar
  if (query.includes('estado')) {
    const porEstado = {};
    datos.forEach(s => {
      const estado = s['Estado Reporte'] || 'Sin estado';
      porEstado[estado] = (porEstado[estado] || 0) + 1;
    });
    labels = Object.keys(porEstado);
    valores = labels.map(e => porEstado[e]);
    titulo = 'Solicitudes por Estado';
    tipoGrafica = 'pie';
    textoRespuesta = `üìä Generando gr√°fica de solicitudes por estado...`;
  } else if (query.includes('tipo') || query.includes('reporte')) {
    const porTipo = {};
    datos.forEach(s => {
      const tipo = s['Tipo de reporte'] || 'Sin tipo';
      porTipo[tipo] = (porTipo[tipo] || 0) + 1;
    });
    const sorted = Object.entries(porTipo).sort((a,b) => b[1] - a[1]).slice(0, 10);
    labels = sorted.map(e => e[0]);
    valores = sorted.map(e => e[1]);
    titulo = 'Top 10 Tipos de Reporte';
    textoRespuesta = `üìä Generando gr√°fica de los top 10 tipos de reporte...`;
  } else if (query.includes('colonia')) {
    const porColonia = {};
    datos.forEach(s => {
      const colonia = (s.name || s.Colonia || s.colonia || 'Sin colonia').trim();
      porColonia[colonia] = (porColonia[colonia] || 0) + 1;
    });
    const sorted = Object.entries(porColonia).sort((a,b) => b[1] - a[1]).slice(0, 10);
    labels = sorted.map(e => e[0]);
    valores = sorted.map(e => e[1]);
    titulo = 'Top 10 Colonias';
    textoRespuesta = `üìä Generando gr√°fica de colonias con m√°s solicitudes...`;
  } else if (query.includes('secci√≥n') || query.includes('seccion') || query.includes('tipo de secci√≥n')) {
    // ‚úÖ NUEVO: Gr√°fica por secci√≥n
    const porSeccion = {};
    datos.forEach(s => {
      const seccion = s.transi || s.Transi || s.TRANSI || 'Sin secci√≥n';
      porSeccion[seccion] = (porSeccion[seccion] || 0) + 1;
    });
    const sorted = Object.entries(porSeccion).sort((a,b) => b[1] - a[1]);
    labels = sorted.map(e => e[0]);
    valores = sorted.map(e => e[1]);
    titulo = 'Solicitudes por Secci√≥n';
    textoRespuesta = `üìä Generando gr√°fica de solicitudes por secci√≥n...`;
  } else if (query.includes('mes')) {
    const porMes = {};
    const fechasMap = {}; // Para ordenar cronol√≥gicamente
    datos.forEach(s => {
      if (s['Fecha reporte']) {
        const fecha = new Date(s['Fecha reporte']);
        const mes = fecha.toLocaleString('es-ES', { month: 'short', year: 'numeric' });
        porMes[mes] = (porMes[mes] || 0) + 1;
        if (!fechasMap[mes]) fechasMap[mes] = fecha;
      }
    });
    // Ordenar cronol√≥gicamente
    const sorted = Object.entries(porMes).sort((a, b) => fechasMap[a[0]] - fechasMap[b[0]]);
    labels = sorted.map(e => e[0]);
    valores = sorted.map(e => e[1]);
    titulo = 'Solicitudes por Mes';
    tipoGrafica = 'line';
    textoRespuesta = `üìä Generando gr√°fica de solicitudes por mes...`;
  } else {
    // Gr√°fica por defecto: estado
    const porEstado = {};
    datos.forEach(s => {
      const estado = s['Estado Reporte'] || 'Sin estado';
      porEstado[estado] = (porEstado[estado] || 0) + 1;
    });
    labels = Object.keys(porEstado);
    valores = labels.map(e => porEstado[e]);
    titulo = 'Solicitudes por Estado';
    tipoGrafica = 'pie';
    textoRespuesta = `üìä Generando gr√°fica de solicitudes...`;
  }
  
  if (descripcionFiltros.length > 0) {
    textoRespuesta += `\n\n**Filtros aplicados:** ${descripcionFiltros.join(', ')}`;
    textoRespuesta += `\n**Total:** ${datos.length.toLocaleString('es-MX')} solicitudes`;
  }
  
  // Generar la gr√°fica
  setTimeout(() => crearGraficaEnChat(tipoGrafica, labels, valores, titulo), 100);
  
  return textoRespuesta;
}

function crearGraficaEnChat(tipo, labels, valores, titulo) {
  const messagesContainer = document.getElementById('chatbotMessages');
  const chartId = `chatChart${contadorGraficas++}`;
  
  // Crear contenedor de la gr√°fica
  const chartDiv = document.createElement('div');
  chartDiv.className = 'chatbot-message system';
  chartDiv.innerHTML = `
    <div class="chatbot-chart-container">
      <canvas id="${chartId}"></canvas>
    </div>
  `;
  messagesContainer.appendChild(chartDiv);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;
  
  // Crear la gr√°fica
  const ctx = document.getElementById(chartId).getContext('2d');
  
  const colores = tipo === 'pie' ? [
    'rgba(146, 43, 33, 0.8)',
    'rgba(109, 31, 24, 0.8)',
    'rgba(211, 84, 0, 0.8)',
    'rgba(244, 143, 177, 0.8)',
    'rgba(156, 39, 176, 0.8)'
  ] : 'rgba(146, 43, 33, 0.8)';
  
  new Chart(ctx, {
    type: tipo,
    data: {
      labels: labels,
      datasets: [{
        label: titulo,
        data: valores,
        backgroundColor: colores,
        borderColor: tipo === 'line' ? 'rgba(146, 43, 33, 1)' : 'rgba(255, 255, 255, 1)',
        borderWidth: tipo === 'line' ? 3 : 2,
        // Para gr√°ficas de l√≠neas: mostrar puntos
        pointBackgroundColor: tipo === 'line' ? 'rgba(146, 43, 33, 1)' : undefined,
        pointBorderColor: tipo === 'line' ? '#fff' : undefined,
        pointBorderWidth: tipo === 'line' ? 2 : undefined,
        pointRadius: tipo === 'line' ? 6 : undefined,
        pointHoverRadius: tipo === 'line' ? 8 : undefined,
        fill: tipo === 'line' ? false : undefined,
        tension: tipo === 'line' ? 0.3 : undefined
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: true,
      plugins: {
        legend: {
          display: tipo === 'pie',
          position: 'bottom'
        },
        title: {
          display: true,
          text: titulo,
          font: { size: 14, weight: 'bold' }
        }
      },
      scales: tipo !== 'pie' ? {
        y: {
          beginAtZero: true,
          ticks: { precision: 0 }
        }
      } : {}
    }
  });
}

function generarRespuestaConTabla(query, datos, descripcionFiltros) {
  if (datos.length === 0) {
    return `‚ùå No hay datos para generar la tabla.`;
  }
  
  let textoRespuesta = '';
  let filas = [];
  let columnas = [];
  let titulo = '';
  
  // Determinar qu√© tipo de tabla generar
  if (query.includes('mes') || query.includes('mensual')) {
    // Tabla por mes - ‚úÖ MEJORADO con filtros en t√≠tulo
    const porMes = {};
    const fechasMap = {}; // Para ordenar cronol√≥gicamente
    datos.forEach(s => {
      if (s['Fecha reporte']) {
        const fecha = new Date(s['Fecha reporte']);
        const mes = fecha.toLocaleString('es-ES', { month: 'long', year: 'numeric' });
        porMes[mes] = (porMes[mes] || 0) + 1;
        if (!fechasMap[mes]) fechasMap[mes] = fecha;
      }
    });
    
    columnas = ['Mes', 'Cantidad'];
    // Ordenar por fecha cronol√≥gicamente
    const sorted = Object.entries(porMes).sort((a, b) => fechasMap[a[0]] - fechasMap[b[0]]);
    filas = sorted.map(([mes, cant]) => [mes, cant.toLocaleString('es-MX')]);
    const total = filas.reduce((sum, row) => sum + parseInt(row[1].replace(/,/g, '')), 0);
    filas.push(['TOTAL', total.toLocaleString('es-MX')]);
    
    let tituloBase = 'Solicitudes por Mes';
    if (descripcionFiltros.length > 0) {
      tituloBase += ` (${descripcionFiltros.join(', ')})`;
    }
    titulo = tituloBase;
    textoRespuesta = `üìä Generando tabla de ${tituloBase.toLowerCase()}...`;
    
  } else if (query.includes('colonia')) {
    // Tabla por colonia - ‚úÖ MEJORADO: Detectar "top X" y crear t√≠tulo din√°mico
    const porColonia = {};
    datos.forEach(s => {
      const colonia = (s.name || s.Colonia || s.colonia || 'Sin colonia').trim();
      porColonia[colonia] = (porColonia[colonia] || 0) + 1;
    });
    
    // Detectar "top X" en la query
    const matchTop = query.match(/top\s+(\d+)/i);
    const topN = matchTop ? parseInt(matchTop[1]) : 20;
    
    columnas = ['Colonia', 'Cantidad'];
    const sorted = Object.entries(porColonia)
      .sort((a,b) => b[1] - a[1])  // Ordenar por cantidad descendente
      .slice(0, topN);  // Limitar al n√∫mero solicitado
    
    filas = sorted.map(([col, cant]) => [col, cant.toLocaleString('es-MX')]);
    const total = datos.length;
    filas.push(['TOTAL', total.toLocaleString('es-MX')]);
    
    // ‚úÖ Crear t√≠tulo din√°mico basado en filtros y n√∫mero solicitado
    let tituloBase = `Top ${topN} Colonias`;
    if (descripcionFiltros.length > 0) {
      tituloBase += ` (${descripcionFiltros.join(', ')})`;
    }
    titulo = tituloBase;
    textoRespuesta = `üìä Generando tabla de ${tituloBase.toLowerCase()}...`;
    
  } else if (query.includes('secci√≥n') || query.includes('seccion') || query.includes('tipo de secci√≥n')) {
    // ‚úÖ NUEVO: Tabla por secci√≥n - MEJORADO con top X din√°mico
    const porSeccion = {};
    datos.forEach(s => {
      const seccion = s.transi || s.Transi || s.TRANSI || 'Sin secci√≥n';
      porSeccion[seccion] = (porSeccion[seccion] || 0) + 1;
    });
    
    // Detectar "top X" en la query
    const matchTop = query.match(/top\s+(\d+)/i);
    const topN = matchTop ? parseInt(matchTop[1]) : 8;
    
    columnas = ['Secci√≥n', 'Cantidad'];
    const sorted = Object.entries(porSeccion)
      .sort((a,b) => b[1] - a[1])
      .slice(0, topN);
    
    filas = sorted.map(([sec, cant]) => [sec, cant.toLocaleString('es-MX')]);
    const total = datos.length;
    filas.push(['TOTAL', total.toLocaleString('es-MX')]);
    
    // ‚úÖ Crear t√≠tulo din√°mico
    let tituloBase = `Top ${topN} Secciones`;
    if (descripcionFiltros.length > 0) {
      tituloBase += ` (${descripcionFiltros.join(', ')})`;
    }
    titulo = tituloBase;
    textoRespuesta = `üìä Generando tabla de ${tituloBase.toLowerCase()}...`;
    
  } else if (query.includes('tipo')) {
    // Tabla por tipo de reporte - ‚úÖ MEJORADO con t√≠tulo din√°mico
    const porTipo = {};
    datos.forEach(s => {
      const tipo = s['Tipo de reporte'] || 'Sin tipo';
      porTipo[tipo] = (porTipo[tipo] || 0) + 1;
    });
    
    columnas = ['Tipo de Reporte', 'Cantidad'];
    const sorted = Object.entries(porTipo).sort((a,b) => b[1] - a[1]);
    filas = sorted.map(([tipo, cant]) => [tipo, cant.toLocaleString('es-MX')]);
    const total = datos.length;
    filas.push(['TOTAL', total.toLocaleString('es-MX')]);
    
    let tituloBase = 'Solicitudes por Tipo';
    if (descripcionFiltros.length > 0) {
      tituloBase += ` (${descripcionFiltros.join(', ')})`;
    }
    titulo = tituloBase;
    textoRespuesta = `üìä Generando tabla de ${tituloBase.toLowerCase()}...`;
    
  } else if (query.includes('estado')) {
    // Tabla por estado - ‚úÖ MEJORADO con t√≠tulo din√°mico
    const porEstado = {};
    datos.forEach(s => {
      const estado = s['Estado Reporte'] || 'Sin estado';
      porEstado[estado] = (porEstado[estado] || 0) + 1;
    });
    
    columnas = ['Estado', 'Cantidad'];
    filas = Object.entries(porEstado).map(([est, cant]) => [est, cant.toLocaleString('es-MX')]);
    const total = datos.length;
    filas.push(['TOTAL', total.toLocaleString('es-MX')]);
    
    let tituloBase = 'Solicitudes por Estado';
    if (descripcionFiltros.length > 0) {
      tituloBase += ` (${descripcionFiltros.join(', ')})`;
    }
    titulo = tituloBase;
    textoRespuesta = `üìä Generando tabla de ${tituloBase.toLowerCase()}...`;
    
  } else {
    // Tabla por defecto: por mes - ‚úÖ MEJORADO con filtros en t√≠tulo
    const porMes = {};
    const fechasMap = {}; // Para ordenar cronol√≥gicamente
    datos.forEach(s => {
      if (s['Fecha reporte']) {
        const fecha = new Date(s['Fecha reporte']);
        const mes = fecha.toLocaleString('es-ES', { month: 'long', year: 'numeric' });
        porMes[mes] = (porMes[mes] || 0) + 1;
        if (!fechasMap[mes]) fechasMap[mes] = fecha;
      }
    });
    
    columnas = ['Mes', 'Cantidad'];
    // Ordenar por fecha cronol√≥gicamente
    const sorted = Object.entries(porMes).sort((a, b) => fechasMap[a[0]] - fechasMap[b[0]]);
    filas = sorted.map(([mes, cant]) => [mes, cant.toLocaleString('es-MX')]);
    const total = filas.reduce((sum, row) => sum + parseInt(row[1].replace(/,/g, '')), 0);
    filas.push(['TOTAL', total.toLocaleString('es-MX')]);
    
    let tituloBase = 'Solicitudes por Mes';
    if (descripcionFiltros.length > 0) {
      tituloBase += ` (${descripcionFiltros.join(', ')})`;
    }
    titulo = tituloBase;
    textoRespuesta = `üìä Generando tabla de ${tituloBase.toLowerCase()}...`;
  }
  
  if (descripcionFiltros.length > 0) {
    textoRespuesta += `\n\n**Filtros aplicados:** ${descripcionFiltros.join(', ')}`;
    textoRespuesta += `\n**Total:** ${datos.length.toLocaleString('es-MX')} solicitudes`;
  }
  
  // Generar la tabla
  setTimeout(() => crearTablaEnChat(columnas, filas, titulo), 100);
  
  return textoRespuesta;
}

function crearTablaEnChat(columnas, filas, titulo) {
  const messagesContainer = document.getElementById('chatbotMessages');
  
  // Crear HTML de la tabla
  let tableHTML = `<table><thead><tr>`;
  columnas.forEach(col => {
    tableHTML += `<th>${col}</th>`;
  });
  tableHTML += `</tr></thead><tbody>`;
  
  filas.forEach((fila, index) => {
    const isTotal = index === filas.length - 1 && fila[0] === 'TOTAL';
    tableHTML += `<tr${isTotal ? ' class="total-row"' : ''}>`;
    fila.forEach(cell => {
      tableHTML += `<td>${cell}</td>`;
    });
    tableHTML += `</tr>`;
  });
  
  tableHTML += `</tbody></table>`;
  
  // Crear contenedor de la tabla
  const tableDiv = document.createElement('div');
  tableDiv.className = 'chatbot-message system';
  tableDiv.innerHTML = `
    <div class="chatbot-table-container">
      <h4 style="margin:0 0 10px 0; color:#922B21;">${titulo}</h4>
      ${tableHTML}
    </div>
  `;
  messagesContainer.appendChild(tableDiv);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

</script>

</div> <!-- Fin de geoportalContent -->

<!-- ========== FIREBASE AUTHENTICATION ========== -->
<script>
  // Configuraci√≥n de Firebase
  const firebaseConfig = {
    apiKey: "AIzaSyBu_-ViuSPQVZS2z6CGPsNpDOvF1xfZIbc",
    authDomain: "solicitudesciudadanasdalia.firebaseapp.com",
    projectId: "solicitudesciudadanasdalia",
    storageBucket: "solicitudesciudadanasdalia.firebasestorage.app",
    messagingSenderId: "553000274461",
    appId: "1:553000274461:web:9b788127280e810b8cd4f4"
  };

  // Inicializar Firebase
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();
  let logoutSolicitado = false;

  setTimeout(() => {
    const emailInput = document.getElementById('emailLogin');
    if (emailInput) emailInput.focus();
  }, 0);

  // ‚úÖ IMPORTANTE: Deshabilitar persistencia de sesi√≥n (cerrar sesi√≥n en cada recarga)
  auth.setPersistence(firebase.auth.Auth.Persistence.NONE);

  // Obtener IP del usuario
  async function getClientIP() {
    try {
      const response = await fetch('https://api.ipify.org?format=json');
      const data = await response.json();
      return data.ip;
    } catch {
      return 'desconocida';
    }
  }

  // Registrar acceso en Firestore
  async function registrarAcceso(email) {
    try {
      const ip = await getClientIP();
      await db.collection('accesos').add({
        email: email,
        ip: ip,
        fecha: new Date(),
        dispositivo: navigator.userAgent,
        navegador: navigator.userAgent.split(')')[0].split('(')[1] || 'desconocido'
      });
      console.log('‚úÖ Acceso registrado en Firestore');
    } catch (error) {
      console.error('‚ùå Error registrando acceso:', error);
    }
  }

  // Login
  document.getElementById('loginForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('emailLogin').value;
    const password = document.getElementById('passwordLogin').value;
    const errorDiv = document.getElementById('errorLogin');
    const spinner = document.getElementById('loginSpinner');
    const btnLogin = document.getElementById('btnLogin');

    errorDiv.textContent = 'Verificando credenciales...';
    errorDiv.style.color = '#922B21';
    spinner.style.display = 'block';
    spinner.setAttribute('aria-hidden', 'false');
    btnLogin.disabled = true;
    btnLogin.style.opacity = '0.7';
    btnLogin.style.cursor = 'not-allowed';

    try {
      await auth.signInWithEmailAndPassword(email, password);
      mostrarGeoportal(email);
      registrarAcceso(email).catch((e) => {
        console.warn('No se pudo registrar acceso (no bloqueante):', e);
      });
    } catch (error) {
      errorDiv.style.color = '#dc3545';
      if (
        error.code === 'auth/user-not-found' ||
        error.code === 'auth/wrong-password' ||
        error.code === 'auth/invalid-credential' ||
        error.code === 'auth/invalid-login-credentials'
      ) {
        errorDiv.textContent = 'Usuario o Contrase√±a no v√°lidos';
      } else if (error.code === 'auth/invalid-email') {
        errorDiv.textContent = 'Email inv√°lido';
      } else {
        errorDiv.textContent = 'Error: ' + error.message;
      }
    } finally {
      spinner.style.display = 'none';
      spinner.setAttribute('aria-hidden', 'true');
      btnLogin.disabled = false;
      btnLogin.style.opacity = '1';
      btnLogin.style.cursor = 'pointer';
    }
  });

  // Logout
  document.getElementById('btnLogout').addEventListener('click', () => {
    logoutSolicitado = true;
    auth.signOut();
  });

  // Mostrar geoportal
  function mostrarGeoportal(email) {
    document.getElementById('loginContainer').style.display = 'none';
    document.getElementById('geoportalContent').style.display = 'block';
    document.getElementById('userInfo').textContent = 'üë§ ' + email;
    iniciarCargaGeoportal();
    
    // ‚úÖ IMPORTANTE: Recalcular tama√±o del mapa y restaurar vista correcta
    setTimeout(() => {
      if (typeof map !== 'undefined' && map) {
        map.invalidateSize();
        map.setView([19.35, -99.2], 13);
      }
    }, 100);
  }

  // Ocultar geoportal
  function ocultarGeoportal(limpiarCampos = false) {
    document.getElementById('loginContainer').style.display = 'flex';
    document.getElementById('geoportalContent').style.display = 'none';
    if (limpiarCampos) {
      document.getElementById('emailLogin').value = '';
      document.getElementById('passwordLogin').value = '';
      document.getElementById('errorLogin').textContent = '';
    }

    const spinner = document.getElementById('loginSpinner');
    const btnLogin = document.getElementById('btnLogin');
    if (spinner) {
      spinner.style.display = 'none';
      spinner.setAttribute('aria-hidden', 'true');
    }
    if (btnLogin) {
      btnLogin.disabled = false;
      btnLogin.style.opacity = '1';
      btnLogin.style.cursor = 'pointer';
    }

    setTimeout(() => {
      const emailInput = document.getElementById('emailLogin');
      if (emailInput) emailInput.focus();
    }, 0);
  }

  // Verificar estado de autenticaci√≥n (pero NO auto-login)
  auth.onAuthStateChanged((user) => {
    if (user) {
      console.log('‚úÖ Usuario autenticado:', user.email);
      // NO mostrar geoportal autom√°ticamente - solo en login exitoso
    } else {
      console.log('‚ùå No hay usuario autenticado');
      ocultarGeoportal(logoutSolicitado);
      logoutSolicitado = false;
    }
  });
</script>

</body>
</html>
